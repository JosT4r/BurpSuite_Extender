#!/usr/bin/env python


import contextlib as __stickytape_contextlib

@__stickytape_contextlib.contextmanager
def __stickytape_temporary_dir():
    import tempfile
    import shutil
    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)

with __stickytape_temporary_dir() as __stickytape_working_dir:
    def __stickytape_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __stickytape_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    open(os.path.join(partial_path, "__init__.py"), "w").write("\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__stickytape_working_dir, path)
        with open(full_path, "w") as module_file:
            module_file.write(contents)

    import sys as __stickytape_sys
    __stickytape_sys.path.insert(0, __stickytape_working_dir)

    __stickytape_write_module('burp_ext/extender.py', 'import platform\n\nif platform.system() != "Java":\n    print("Load this file inside jython, if you need the stand-alone tool run: inql")\n    exit(-1)\n\nimport os\nimport shutil\nimport tempfile\n\nfrom burp import (IBurpExtender, IScannerInsertionPointProvider, IExtensionStateListener)\n\nfrom inql.burp_ext.editor import GraphQLEditorTab\nfrom inql.burp_ext.scanner import BurpScannerCheck\nfrom inql.burp_ext.generator_tab import GeneratorTab\nfrom inql import __version__\nfrom inql.burp_ext.timer_tab import TimerTab\nfrom inql.utils import stop\n\nclass BurpExtender(IBurpExtender, IScannerInsertionPointProvider, IExtensionStateListener):\n    """\n    Main Class for Burp Extenders\n    """\n\n    def registerExtenderCallbacks(self, callbacks):\n        """\n        Overrides IBurpExtender method, it registers all the elements that compose this extension\n\n        :param callbacks:  burp callbacks\n        :return: None\n        """\n        self._tmpdir = tempfile.mkdtemp()\n        os.chdir(self._tmpdir)\n        helpers = callbacks.getHelpers()\n        callbacks.setExtensionName("InQL: Introspection GraphQL Scanner %s" % __version__)\n        callbacks.issueAlert("InQL Scanner Started")\n        print("InQL Scanner Started! (tmpdir: %s )" % os.getcwd())\n        # Registering GraphQL Tab\n        callbacks.registerMessageEditorTabFactory(lambda _, editable: GraphQLEditorTab(callbacks, editable))\n        # Register ourselves as a custom scanner check\n        callbacks.registerScannerCheck(BurpScannerCheck(callbacks))\n        # Register Suite Tab(s)\n        self._tab = GeneratorTab(callbacks, helpers)\n        callbacks.addSuiteTab(self._tab)\n        callbacks.addSuiteTab(TimerTab(callbacks, helpers))\n        # Register extension state listener\n        callbacks.registerExtensionStateListener(self)\n\n    def extensionUnloaded(self):\n        """\n        Overrides IExtensionStateListener method, it unregisters all the element that compose this extension and it will save the\n        state if available.\n\n        :return: None\n        """\n        os.chdir(\'/\')\n        shutil.rmtree(self._tmpdir, ignore_errors=False, onerror=None)\n        stop()\n        self._tab.save()\n')
    __stickytape_write_module('inql/burp_ext/editor.py', 'import platform\n\nif platform.system() != "Java":\n    print("Load this file inside jython, if you need the stand-alone tool run: inql")\n    exit(-1)\n\nimport json\n\nfrom burp import IMessageEditorTab\n\nfrom javax.swing import JFrame, JPanel, JLabel, JSplitPane\nfrom java.awt import BorderLayout\n\nfrom inql.widgets.payloadview import PayloadView\n\n\nclass GraphQLEditorTab(IMessageEditorTab):\n    """\n    GraphQL Editor TAB\n    """\n    def __init__(self,  callbacks, editable):\n        self.payload_view = PayloadView(payload=\'\', texteditor_factory=callbacks.createTextEditor, editable=editable)\n        self._helpers = callbacks.getHelpers()\n        self._currentMessage = \'\'\n\n    def getTabCaption(self):\n        """\n        Define Message Editor Properties for GQL Editor\n\n        :return: InQL burp message editor name\n        """\n        return "InQL"\n\n    def getUiComponent(self):\n        """\n        Get UI Component. Overrides IMessageEditorTab.\n\n        :return: UI txt component\n        """\n        return self.payload_view.this\n\n    def isEnabled(self, content, isRequest):\n        """\n        Check if we can enable or not the MessageEditorTab. Overrides IMessageEditorTab.\n\n        :param content: message request/response\n        :param isRequest: check if is request\n        :return: True or False depending if the request is enabled to be edited with this tab.\n        """\n        try:\n            if isRequest:\n                rBody = self._helpers.analyzeRequest(content)\n\n            else:\n                rBody = self._helpers.analyzeResponse(content)\n\n            message = content[rBody.getBodyOffset():].tostring().strip()\n            content = json.loads(str(message))\n            if isinstance(content, list):\n                content = content[0]\n\n            return \'query\' in content and \\\n                   any([content[\'query\'].strip().startswith(qtype) for qtype in [\'query\', \'mutation\', \'subscription\', \'{\']])\n        except Exception:\n            return False\n\n    def setMessage(self, content, isRequest):\n        """\n        Message Setter. Overrides IMessageEditorTab.\n\n        :param content: message request/response\n        :param isRequest: check if is request\n        :return: the modified body\n        """\n        if content is not None:\n            r = self._helpers.analyzeRequest(content)\n            self._currentMessage = content\n            message = content[r.getBodyOffset():].tostring()\n\n            try:\n                self.payload_view.refresh(message)\n            except ValueError:\n                pass\n\n    def getMessage(self):\n        """\n        Message Getter. Overrides IMessageEditorTab.\n\n        :return: the current message\n        """\n        if self.isModified():\n            try:\n                request_body = self.payload_view.textarea().getText()\n                r = self._helpers.analyzeRequest(self._currentMessage)\n                return self._helpers.buildHttpMessage(r.getHeaders(), request_body)\n            except Exception as ex:\n                print(ex)\n                return self._helpers.buildHttpMessage(r.getHeaders(), self._currentMessage[r.getBodyOffset():].tostring())\n\n\n    def isModified(self):\n        """\n        Check if the message was modified.\n\n        :return: True if the message was modified.\n        """\n        r = self._helpers.analyzeRequest(self._currentMessage)\n        return self._currentMessage[r.getBodyOffset():].tostring() != self.payload_view.textarea().getText()\n\n\n    def getSeletedData(self):\n        """\n        Return the selected data.\n\n        :return: the selected string.\n        """\n        return  self.payload_view.textarea().getSeletedText()')
    __stickytape_write_module('inql/widgets/payloadview.py', 'from __future__ import print_function\n\nimport platform\n\nif platform.system() != "Java":\n    print("Load this file inside jython, if you need the stand-alone tool run: inql")\n    exit(-1)\n\nfrom javax.swing import JFrame, JPanel, JLabel, JScrollPane, JTextArea, JTabbedPane, JSplitPane, SwingUtilities\nfrom javax.swing.event import DocumentListener\nfrom java.awt import BorderLayout, Color\n\nimport json\n\nfrom inql.utils import inherits_popup_menu\n\nclass _PayloadListener(DocumentListener):\n    """\n    PayloadListener wrapper is a java DocumentListener wrapper for python lambdas\n    """\n    def __init__(self, event_listener=lambda e: None, changed_update=None, remove_update=None, insert_update=None):\n        self.changed_update = changed_update if changed_update else event_listener\n        self.remove_update = changed_update if changed_update else event_listener\n        self.insert_update = changed_update if changed_update else event_listener\n\n    def removeUpdate(self, e):\n        self.remove_update(e)\n\n    def insertUpdate(self, e):\n        self.insert_update(e)\n\n    def changedUpdate(self, e):\n        self.changed_update(e)\n\nBaseTabbedPaneUI = JTabbedPane().getUI().getClass()\n\nclass SneakTabbedPaneUI(BaseTabbedPaneUI):\n    def __init__(self, tabbed_pane):\n        self.tabbed_pane = tabbed_pane\n\n    def calculateTabAreaHeight(self, tab_placement, run_count, max_tab_height):\n        if self.tabbed_pane.getTabCount() > 1:\n            return self.super__calculateTabAreaHeight(tab_placement, run_count, max_tab_height)\n        else:\n            return 0\n\n\nclass PayloadView:\n    """\n    PayloadView is a TextView viewer and editor.\n    """\n    def __init__(self, payload=None, texteditor_factory=None, editable=True):\n        self._idx = 0\n\n        self._texteditor_factory = texteditor_factory\n        self._textareas = {}\n        self._widgets = {}\n\n        self._listener = None\n\n        self.this = JTabbedPane()\n        self.this.setUI(SneakTabbedPaneUI(self.this))\n\n        if payload:\n            self.refresh(payload)\n        self.editable = editable\n        self.set_editable(editable)\n\n    def _get_textarea(self, element):\n        """\n        Recursive search for a textarea in the components of a given supercomponent\n\n        :param element: current widget.\n        :return: None\n        """\n        try:\n            if \'getDocument\' in dir(element) and \'append\' in dir(element) and JTextArea in element.__class__.__mro__:\n                return element\n\n            for e in element.getComponents():\n                ret = self._get_textarea(e)\n                if ret:\n                    return ret\n\n        except:\n            return None\n\n    def _create_texteditor(self, name=None, label=None):\n        _textarea = None\n\n        if name and name in self._widgets:\n            return self._widgets[name]\n\n        if not name:\n            name = "TextArea#%s" % self._idx\n            self._idx += 1\n\n        this = JPanel()\n\n        # Add a label\n        if label:\n            this.setLayout(BorderLayout())\n            this.add(BorderLayout.PAGE_START, JLabel(label))\n\n        if self._texteditor_factory:\n            _texteditor = self._texteditor_factory()\n            _component = _texteditor.getComponent()\n            this.add(BorderLayout.CENTER, _component)\n            _textarea = self._get_textarea(_component)\n\n        if not _textarea:\n            _textarea = JTextArea()\n            _textarea.setColumns(20)\n            _textarea.setRows(5)\n            _textarea.setLineWrap(True)\n            _textarea.setWrapStyleWord(True)\n            _textarea.setEditable(True)\n            _textarea.setName(name)\n            _textarea.setSelectionColor(Color(255, 153, 51))\n            _textarea.requestFocus()\n            # Add textarea to a scrollable JPane\n            _scrollpane = JScrollPane()\n            _scrollpane.setViewportView(_textarea)\n            this.add(BorderLayout.CENTER, _scrollpane)\n\n        _textarea.setEditable(self.editable)\n\n        self._textareas[name] = _textarea\n        self._widgets[name] = this\n\n        def on_change(evt):\n            if not self._textareas[name].hasFocus():\n                return\n            try:\n                if name == "raw":\n                    SwingUtilities.invokeLater(lambda: self._refresh_queries(self._textareas[\'raw\'].getText()))\n                elif name.startswith(\'gql_query#\'):\n                    id = int(name.split("#")[1])\n                    content = json.loads(self._textareas[\'raw\'].getText())\n                    if id == 0 and not isinstance(content, list):\n                        content[\'query\'] = self._textareas[name].getText()\n                    else:\n                        content[id][\'query\'] = self._textareas[name].getText()\n                    SwingUtilities.invokeLater(lambda: self._textareas[\'raw\'].setText(json.dumps(content)))\n                elif name.startswith(\'gql_variables#\'):\n                    id = int(name.split("#")[1])\n                    content = json.loads(self._textareas[\'raw\'].getText())\n                    if id == 0 and not isinstance(content, list):\n                        content[\'variables\'] = json.loads(self._textareas[name].getText())\n                    else:\n                        content[id][\'variables\'] = json.loads(self._textareas[name].getText())\n                    SwingUtilities.invokeLater(lambda: self._textareas[\'raw\'].setText(json.dumps(content)))\n            except ValueError:\n                pass # Avoid crashing for JSON not valid incompatibilities\n\n        _textarea.getDocument().addDocumentListener(_PayloadListener(changed_update=on_change))\n\n        return this\n\n    def set_editable(self, editable):\n        """\n        Enable or Disable the editable textview\n\n        :param editable: boolean parameter representing the editability\n        :return: None\n        """\n        self.editable = editable\n        for t in self._textareas.values():\n            t.setEditable(editable)\n\n\n    def _graphql_queries(self, payload):\n        try:\n            content = json.loads(payload)\n            if not isinstance(content, list):\n                content = [content]\n\n            q = {}\n\n            for i in range(0, len(content)):\n                if any([\'query\' in content[i] and content[i][\'query\'].strip().startswith(qtype) for qtype in [\'query\', \'mutation\', \'subscription\', \'{\']]):\n                    q[i] = content[i]\n\n            return q\n        except ValueError:\n            return None\n\n    def _refresh_raw(self, payload):\n        """\n        Refresh the textarea content with a new payload, if present\n\n        :param payload:\n        :return: None\n        """\n\n        if payload:\n            self.this.addTab("Raw", self._create_texteditor(name="raw", label=\'Raw\'))\n            self._textareas[\'raw\'].setText(payload)\n            if self._listener:\n                self.add_listener(self._listener)\n            inherits_popup_menu(self.this)\n\n    def _get_tab_component_by_name(self, name):\n        for i in range(0, self.this.getTabCount()):\n            if self.this.getTitleAt(i) == name:\n                return self.this.getComponentAt(i)\n\n        return None\n\n    def _get_tab_index_by_name(self, name):\n        for i in range(0, self.this.getTabCount()):\n            if self.this.getTitleAt(i) == name:\n                return i\n\n        return -1\n\n    def _refresh_queries(self, payload):\n        """\n        Refresh the textarea content with a new payload, if present\n\n        :param payload:\n        :return: None\n        """\n        graphql_tabs = []\n        for i in range(0, self.this.getTabCount()):\n            if self.this.getTitleAt(i).startswith("GraphQL #"):\n                graphql_tabs.append(self.this.getTitleAt(i))\n\n        if payload:\n            # Check if the payload contains a GraphQL query object\n            queries = self._graphql_queries(payload)\n            if queries:\n                # Generate and append GraphQL tab to the tabs\n                for query_key in queries.keys():\n                    qname = "gql_query#%s" % query_key\n                    vname = "gql_variables#%s" % query_key\n                    tname = "GraphQL #%s" % query_key\n                    queryeditor = self._create_texteditor(name=qname, label="Query:")\n                    self._textareas[qname].setText(queries[query_key][\'query\'])\n                    variableseditor = self._create_texteditor(name=vname, label="Variables:")\n                    this = self._get_tab_component_by_name(tname)\n                    if tname in graphql_tabs:\n                        graphql_tabs.remove(tname)\n                    if not this:\n                        this = JSplitPane(JSplitPane.VERTICAL_SPLIT, queryeditor, variableseditor)\n                    self.this.addTab(tname, this)\n                    this.setOneTouchExpandable(True)\n                    this.setDividerLocation(0.66)\n                    if \'variables\' in queries[query_key]:\n                        this.getBottomComponent().setVisible(True)\n                        self._textareas[vname].setText(json.dumps(queries[query_key][\'variables\'], indent=4))\n                    else:\n                        this.getBottomComponent().setVisible(False)\n                        self._textareas[vname].setText("{}")\n\n        # Remove empty graphql tabs\n        try:\n            for tab in graphql_tabs:\n                for i in range(0, self.this.getTabCount()):\n                    if self.this.getTitleAt(i) == tab:\n                        self.this.remove(i)\n        except:\n            # Do nothing if you cannot remove an entry\n            pass\n\n        inherits_popup_menu(self.this)\n\n    def refresh(self, payload):\n        """\n        Refresh the textarea content with a new payload, if present\n\n        :param payload:\n        :return: None\n        """\n        self._refresh_queries(payload)\n        self._refresh_raw(payload)\n        inherits_popup_menu(self.this)\n\n    def textarea(self):\n        return self._textareas[\'raw\']\n\n    def add_listener(self, listener):\n        """\n        add a new listener to the textarea\n\n        :param listener: this parameter should be a lambda or a method\n        :return: None\n        """\n        self._listener = listener\n        if \'raw\' in self._textareas:\n            self._textareas[\'raw\'].getDocument().addDocumentListener(_PayloadListener(listener))\n\n\nif __name__ == "__main__":\n    frame = JFrame("PayloadView")\n    frame.setForeground(Color.black)\n    frame.setBackground(Color.lightGray)\n    cp = frame.getContentPane()\n    ft = PayloadView(payload=\'Payload\')\n    ft.add_listener(lambda e: print(e))\n    cp.add(ft.this)\n    frame.pack()\n    frame.setVisible(True)\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)')
    __stickytape_write_module('inql/utils.py', 'import re\nimport os\nimport time\nimport threading\nimport ssl\nimport json\nimport random\nimport string\n\ntry:\n    import urllib.request as urllib_request # for Python 3\nexcept ImportError:\n    import urllib2 as urllib_request # for Python 2 and Jython\n\ntry:\n    from urllib.parse import urlparse # for Python 3\nexcept ImportError:\n    from urlparse import urlparse # for Python 2 and Jython\n\ntry:\n    from BaseHTTPServer import BaseHTTPRequestHandler\nexcept ImportError:\n    from http.server import BaseHTTPRequestHandler\n\nfrom io import BytesIO\n\ndef string_join(*ss):\n    """\n    String joins with arbitrary lengthy parameters\n\n    :param ss: strings to be joined\n    :return: strings joined\n    """\n    return "".join(ss)\n\n\ndef mkdir_p(path):\n    """\n    Create Directory if it does not exist, exit otherwise\n    :param path:\n    :return:\n    """\n    try:\n        os.makedirs(path)\n    except:\n        if os.path.isdir(path):\n            pass\n        else:\n            raise\n\n\ndef wrap_open(method, exceptions = (OSError, IOError)):\n    """Wrap Open method in order to create containing directories if they does not exist"""\n    def fn(*args, **kwargs):\n        try:\n            mkdir_p(os.path.dirname(args[0]))\n            return method(*args, **kwargs)\n        except exceptions:\n            sys.exit(\'Can\\\'t open \\\'{0}\\\'. Error #{1[0]}: {1[1]}\'.format(args[0], sys.exc_info()[1].args))\n\n    return fn\n\n\nopen = wrap_open(open)\n\n\ndef inherits_popup_menu(element):\n    """\n    Inherits popup menu on each and every child widgets.\n\n    :param element: current widget.\n    :return: None\n    """\n    element.setInheritsPopupMenu(True)\n    try:\n        for e in element.getComponents():\n            inherits_popup_menu(e)\n    except:\n        pass\n\n\nclass AttrDict(dict):\n    """\n    HACK: this class will generate a class object with fields from a dict\n    """\n    def __init__(self, *args, **kwargs):\n        super(AttrDict, self).__init__(*args, **kwargs)\n        self.__dict__ = self\n\n\nURI_REGEX = re.compile("^(OPTIONS|GET|HEAD|POST|PUT|DELETE|TRACE|CONNECT)\\s+([^\\s]+)", re.MULTILINE | re.IGNORECASE)\n\n\ndef override_uri(http_metadata, path=None, query=None, method=None):\n    """\n    Overrides uri with the defined overrides.\n\n    :param http_metadata: an HTTP metadata content\n    :return: a new overridden headers string\n    """\n    m = URI_REGEX.match(http_metadata)\n    method_match = m.group(1)\n    uri = m.group(2)\n    parsed_uri = urlparse(uri)\n    if path:\n        parsed_uri = parsed_uri._replace(path=path)\n    if query:\n        parsed_uri = parsed_uri._replace(query=query)\n    if method:\n        method_match = method\n\n    return re.sub(URI_REGEX,\n                  "%s %s" % (method_match, parsed_uri.geturl()),\n                  http_metadata)\n\n\ndef override_headers(http_metadata, overrideheaders):\n    """\n    Overrides headers with the defined overrides.\n\n    :param http_metadata: an HTTP metadata content\n    :param overrideheaders: an overrideheaders object.\n    :return: a new overridden headers string\n    """\n    ree = [(\n        re.compile("^%s\\s*:\\s*[^\\n]+$" % re.escape(header), re.MULTILINE | re.IGNORECASE),\n        "%s: %s" % (header, val))\n        for (header, val) in overrideheaders]\n    h = http_metadata\n    for find, replace in ree:\n        hn = re.sub(find, replace, h)\n        if hn == h:\n            h = "%s\\n%s" % (hn, str(replace))\n        else:\n            h = hn\n\n    return h\n\n\ndef json_encode(metadata):\n    return {k: json.dumps(v) if not isinstance(v, str) else v for k, v in metadata.items()}\n\n\ndef clean_dict(metadata):\n    return {k: v for k, v in metadata.items() if v is not None}\n\n\ndef random_string():\n    # printing lowercase\n    letters = string.ascii_lowercase\n    return \'\'.join(random.choice(letters) for i in range(10))\n\ndef multipart(data, boundary):\n    ss = []\n    for key, value in data.items():\n        ss.append("\\n".join([\n                    "--%s" % boundary,\n                    "Content-Disposition: form-data; name=\\"%s\\"" % key,\n                    "\\n%s" % value]))\n    ss.append("--%s--" % boundary)\n    return "\\n".join(ss)\n\n\ndef querify(data, parent_key=None, formatter=None):\n    if formatter is  None:\n        formatter = lambda v: v  # Multipart representation of value\n\n    if type(data) is not dict:\n        return {parent_key: formatter(data)}\n\n    converted = []\n\n    for key, value in data.items():\n        current_key = key if parent_key is None else "%s[%s]" % (parent_key, key)\n        if type(value) is dict:\n            converted.extend(querify(value, current_key, formatter).items())\n        elif type(value) is list:\n            for ind, list_value in enumerate(value):\n                iter_key = "%s[%s]" % (current_key, ind)\n                converted.extend(querify(list_value, iter_key, formatter).items())\n        else:\n            converted.append((current_key, formatter(value)))\n\n    return dict(converted)\n\n\ndef nop_evt(evt):\n    """\n    Do nothing on events\n\n    :param evt: ignored\n    :return: None\n    """\n    pass\n\n\ndef nop():\n    """\n    Do nothing\n\n    :return: None\n    """\n    pass\n\n\nstop_watch = False\n\n\ndef stop():\n    global stop_watch\n    stop_watch = True\n\n\ndef watch(execute=nop, interval=60):\n    global stop_watch\n    def async_run():\n        try:\n            while not stop_watch:\n                execute()\n                time.sleep(interval)\n                sys.stdout.flush()\n                sys.stderr.flush()\n        finally:\n            sys.stdout.flush()\n            sys.stderr.flush()\n\n    t = threading.Thread(target=async_run)\n    t.start()\n\n\ndef run_async(execute=nop):\n    def async_run():\n        try:\n            execute()\n        finally:\n            sys.stdout.flush()\n            sys.stderr.flush()\n    threading.Thread(target=async_run).start()\n\n\ndef run_timeout(execute, timeout):\n    def async_run():\n        try:\n            execute()\n        finally:\n            sys.stdout.flush()\n            sys.stderr.flush()\n    t = threading.Thread(target=async_run)\n    t.daemon = True\n    t.start()\n    t.join(timeout=timeout)\n\n\ndef make_http_handler(http_mutator=None):\n    class GraphQLRequestHandler(BaseHTTPRequestHandler):\n        def graphiql_page(self, address, extrascript=""):\n            """\n            Return a graphiql console page given a domain\n            :param listenin_on: address on which the graphiql server proxy is listening on\n            :param domain: input domain on which to perform queries\n            :return: a string representing the graphiql page\n            """\n            return """<html>\n        <head>\n          <title>InQL GraphiQL Console</title>\n          <link href="https://unpkg.com/graphiql/graphiql.min.css" rel="stylesheet" />\n        </head>\n        <body style="margin: 0;">\n          <div id="graphiql" style="height: 100vh;"></div>\n\n          <script\n          crossorigin\n          src="https://unpkg.com/react/umd/react.production.min.js"\n          ></script>\n          <script\n          crossorigin\n          src="https://unpkg.com/react-dom/umd/react-dom.production.min.js"\n          ></script>\n          <script\n          crossorigin\n          src="https://unpkg.com/graphiql/graphiql.min.js"\n          ></script>\n\n          <script>\n\n            /**\n             * This GraphiQL example illustrates how to use some of GraphiQL\'s props\n             * in order to enable reading and updating the URL parameters, making\n             * link sharing of queries a little bit easier.\n             *\n             * This is only one example of this kind of feature, GraphiQL exposes\n             * various React params to enable interesting integrations.\n             */\n\n              // Parse the search string to get url parameters.\n              var address = "%s";\n              var search = window.location.search;\n              var parameters = {};\n              search.substr(1).split(\'&\').forEach(function (entry) {\n                var eq = entry.indexOf(\'=\');\n                if (eq >= 0) {\n                  parameters[decodeURIComponent(entry.slice(0, eq))] =\n                  decodeURIComponent(entry.slice(eq + 1));\n                }\n              });\n\n            // if variables was provided, try to format it.\n            if (parameters.variables) {\n              try {\n                parameters.variables =\n                JSON.stringify(JSON.parse(parameters.variables), null, 2);\n              } catch (e) {\n                    // Do nothing, we want to display the invalid JSON as a string, rather\n                    // than present an error.\n                  }\n                }\n\n            // When the query and variables string is edited, update the URL bar so\n            // that it can be easily shared\n            function onEditQuery(newQuery) {\n              parameters.query = newQuery;\n              updateURL();\n            }\n\n            function onEditVariables(newVariables) {\n              parameters.variables = newVariables;\n              updateURL();\n            }\n\n            function onEditOperationName(newOperationName) {\n              parameters.operationName = newOperationName;\n              updateURL();\n            }\n\n            function updateURL() {\n              var newSearch = \'?\' + Object.keys(parameters).filter(function (key) {\n                return Boolean(parameters[key]);\n              }).map(function (key) {\n                return encodeURIComponent(key) + \'=\' +\n                encodeURIComponent(parameters[key]);\n              }).join(\'&\');\n              history.replaceState(null, null, newSearch);\n            }\n\n            const graphQLFetcher = graphQLParams =>\n            fetch(address, {\n              method: \'post\',\n              headers: { \'Content-Type\': \'application/json\' },\n              body: JSON.stringify(graphQLParams),\n            })\n            .then(response => response.json())\n            .catch(() => response.text());\n            ReactDOM.render(\n              React.createElement(GraphiQL, {\n                fetcher: graphQLFetcher,\n                query: parameters.query,\n                variables: parameters.variables,\n                operationName: parameters.operationName,\n                onEditQuery: onEditQuery,\n                onEditVariables: onEditVariables,\n                onEditOperationName: onEditOperationName\n              }),\n              document.getElementById(\'graphiql\'),\n            );\n            while (document.querySelector(\'.title\') == null) {\n                // wait for the title to be something\n            }\n            document.querySelector(\'.title\').innerHTML = \'<a href="https://github.com/doyensec/inql"><img src="https://github.com/doyensec/inql/blob/master/docs/inql.png?raw=true" style="display: block; height:6em; z-index: 10; position: relative"></img></a>\';\n            %s\n          </script>\n        </body>\n        </html>""" % (address, extrascript)\n\n        # Handler for the GET requests\n        def do_GET(self):\n            self.send_response(200)\n            self.send_header(\'Content-type\', \'text/html\')\n            self.end_headers()\n\n            # Send the html message\n            if http_mutator:\n                page = self.graphiql_page(self.path, extrascript="""(function() {\n              var toolbar = document.querySelector(\'.toolbar\');\n              var sendToRepeater = document.createElement(\'button\');\n              sendToRepeater.classList.add(\'toolbar-button\');\n              sendToRepeater.innerHTML = \'Send To Repeater\';\n              sendToRepeater.title = \'Send To Repeater\';\n              sendToRepeater.setAttribute(\'aria-invalid\', true);\n              sendToRepeater.onclick = function() {\n                var xhr = new XMLHttpRequest();\n                xhr.open("PUT", address, true);\n                xhr.setRequestHeader(\'Content-Type\', \'application/json\');\n                var params = JSON.parse(JSON.stringify(parameters));\n                try {\n                    params[\'variables\'] = JSON.parse(params[\'variables\']);\n                } catch (e) {\n                    console.log(\'Cannot parse parameters\');\n                }\n                xhr.send(JSON.stringify(params));\n              }\n              toolbar.appendChild(sendToRepeater);\n            } ());""")\n            else:\n                page = self.graphiql_page(self.path)\n\n            self.wfile.write(page.encode())\n            return\n\n        def do_POST(self):\n            try:\n                content_len = int(self.headers.getheader(\'content-length\', 0))\n            except AttributeError:  # python3 has not the getheader type, use get instead\n                content_len = int(self.headers.get(\'Content-Length\'))\n\n            host = None\n            body = None\n            try:\n                idx = self.path.find(\'?\')\n                if idx != -1:\n                    endpoint = self.path[1:idx]\n                else:\n                    endpoint = self.path[1:]\n\n                url = urlparse(endpoint)\n                if url.scheme == "https" and url.port == 443 or url.scheme == "http" and url.port == 80:\n                    host = url.hostname\n                else:\n                    host = url.netloc\n                self.headers[\'Host\'] = host\n                body = self.rfile.read(content_len)\n                if not http_mutator:\n                    request = urllib_request.Request(endpoint, body, headers=self.headers)\n                else:\n                    request = http_mutator.build_python_request(endpoint, host, body)\n\n                contents = urlopen(request, verify=not (\'http_proxy\' in os.environ or \'https_proxy\' in os.environ)).read()\n\n                jres = json.loads(contents)\n                if \'errors\' in jres and len(jres[\'errors\']) > 0 and "IntrospectionQuery" in body:\n                    raise Exception("IntrospectionQuery request contains errors")\n\n                self.send_response(200)\n                self.send_header(\'Content-type\', \'application/json\')\n                self.end_headers()\n\n                self.wfile.write(contents)\n            except Exception as ex:\n                if host and http_mutator and http_mutator.get_stub_response(host) and "IntrospectionQuery" in body:\n                    self.send_response(200)\n                    self.send_header(\'Content-type\', \'application/json\')\n                    self.end_headers()\n                    self.wfile.write(http_mutator.get_stub_response(host))\n                    return\n                print(ex)\n                self.send_response(400)\n                self.send_header(\'Content-type\', \'application/json\')\n                self.end_headers()\n\n                try:\n                    # Try to get the 400 page error content since it is used by the GraphiQL Console\n                    self.wfile.write(ex.read())\n                except:\n                    pass\n            return\n\n        def do_PUT(self):\n            try:\n                content_len = int(self.headers.getheader(\'content-length\', 0))\n            except AttributeError:  # python3 has not the getheader type, use get instead\n                content_len = int(self.headers.get(\'Content-Length\'))\n\n            if http_mutator:\n                body = self.rfile.read(content_len)\n                url = urlparse(self.path[1:])\n                if url.scheme == "https" and url.port == 443 or url.scheme == "http" and url.port == 80:\n                    host = url.hostname\n                else:\n                    host = url.netloc\n                http_mutator.send_to_repeater(host, body)\n            else:\n                print(self.path)\n                print(self.rfile.read(content_len))\n\n            self.send_response(200)\n            self.send_header(\'Content-type\', \'application/json\')\n            self.end_headers()\n            return\n    return GraphQLRequestHandler\n\nclass HTTPRequest(BaseHTTPRequestHandler):\n    def __init__(self, request_text):\n        self.rfile = BytesIO(request_text)\n        self.raw_requestline = self.rfile.readline()\n        self.error_code = self.error_message = None\n        self.parse_request()\n\n    def send_error(self, code, message):\n        self.error_code = code\n        self.error_message = message\n\ntry:\n    import sys\n    from javax.net.ssl import TrustManager, X509TrustManager\n    from jarray import array\n    from javax.net.ssl import SSLContext\n\n\n    class TrustAllX509TrustManager(X509TrustManager):\n\n        # Define a custom TrustManager which will blindly\n        # accept all certificates\n        def checkClientTrusted(self, chain, auth):\n            pass\n\n        def checkServerTrusted(self, chain, auth):\n            pass\n\n        def getAcceptedIssuers(self):\n            return None\n\n\n    # Create a static reference to an SSLContext which will use\n    # our custom TrustManager\n    trust_managers = array([TrustAllX509TrustManager()], TrustManager)\n    TRUST_ALL_CONTEXT = SSLContext.getInstance("SSL")\n    TRUST_ALL_CONTEXT.init(None, trust_managers, None)\n\n    # Keep a static reference to the JVM\'s default SSLContext for restoring\n    # at a later time\n    DEFAULT_CONTEXT = SSLContext.getDefault()\n    if \'create_default_context\' not in dir(ssl):\n        SSLContext.setDefault(TRUST_ALL_CONTEXT)\nexcept:\n    pass\n\ndef urlopen(request, verify):\n    ctx = None\n    if \'create_default_context\' in dir(ssl):\n        ctx = ssl.create_default_context()\n    elif \'SSLContext\' in dir(ssl) and \'PROTOCOL_TLSv1\' in dir(ssl):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n\n    if not verify and ctx:\n        ctx.check_hostname = False\n        ctx.verify_mode = ssl.CERT_NONE\n        return urllib_request.urlopen(request, context=ctx)\n    else:\n        return urllib_request.urlopen(request)\n\n\ndef _recursive_name_get(obj):\n    try:\n        return obj[\'name\'] or _recursive_name_get(obj[\'ofType\'])\n    except KeyError:\n        return False\n\n\ndef _recursive_kind_of(obj, target):\n    try:\n        return obj[\'kind\'] == target or _recursive_kind_of(obj[\'ofType\'], target)\n    except KeyError:\n        return False\n    except TypeError:\n        return False\n\ndef is_query(body):\n    # FIXME: handle urlencoded requests too in the future\n    try:\n        content = json.loads(body)\n        if not isinstance(content, list):\n            content = [content]\n\n        ret = all([\'query\' in c or \'operationName\' in c\n                    for c in content])\n        return ret\n    except:\n        return False\n\ndef simplify_introspection(data):\n    """\n    Generates a simplified introspection object based on an introspection query.\n    This utility function is after used by many of the generators.\n\n    # Parsing JSON response/file structure as follows\n    # data\n    #   __schema\n    #       directives\n    #       mutationType\n    #       queryType\n    #       subscriptionType\n    #       types (kind, name, description)\n    #              name (RootQuery, RootMutation, Subscriptions, [custom] OBJECT)\n    #              fields\n    #                     name (query names)\n    #                     args\n    #                            name (args names)\n    #                            type\n    #                                   name (args types)\n\n    :type data: an introspection query dict\n    """\n\n    output = {}\n    output[\'schema\'] = {}\n    schema = data[\'data\'][\'__schema\']\n\n    # Get the Root query type\n    if schema[\'queryType\'] and \'name\' in schema[\'queryType\']:\n        output[\'schema\'][\'query\'] = {\n            "type": schema[\'queryType\'][\'name\'],\n            "array": False,\n            "required": False\n        }\n\n    # Get the Root subscription type\n    if schema[\'subscriptionType\'] and \'name\' in schema[\'subscriptionType\']:\n        output[\'schema\'][\'subscription\'] = {\n            "type": schema[\'subscriptionType\'][\'name\'],\n            "array": False,\n            "required": False\n        }\n\n    # Get the Root mutation type\n    if schema[\'mutationType\'] and \'name\' in schema[\'mutationType\']:\n        output[\'schema\'][\'mutation\'] = {\n            "type": schema[\'mutationType\'][\'name\'],\n            "array": False,\n            "required": False\n        }\n\n    # Go over all the fields and simplify the JSON\n    output[\'type\'] = {}\n    for type in schema[\'types\']:\n        if type[\'name\'][0:2] == \'__\': continue\n        if type[\'kind\'] == \'OBJECT\':\n            output[\'type\'][type[\'name\']] = {}\n            if type[\'fields\']:\n                for field in type[\'fields\']:\n                    output[\'type\'][type[\'name\']][field[\'name\']] = {\n                        "type": _recursive_name_get(field[\'type\']),\n                        "required": field[\'type\'][\'kind\'] == \'NON_NULL\',\n                        "array": _recursive_kind_of(field[\'type\'], \'LIST\'),\n                    }\n                    if field[\'args\']:\n                        output[\'type\'][type[\'name\']][field[\'name\']]["args"] = {}\n                        for arg in field[\'args\']:\n                            output[\'type\'][type[\'name\']][field[\'name\']][\'args\'][arg[\'name\']] = {\n                                "type": _recursive_name_get(arg[\'type\']),\n                                "required": arg[\'type\'][\'kind\'] == \'NON_NULL\',\n                                "array": _recursive_kind_of(arg[\'type\'], \'LIST\'),\n                            }\n                            if arg[\'defaultValue\'] != None:\n                                output[\'type\'][type[\'name\']][field[\'name\']][\'args\'][arg[\'name\']][\'default\'] = arg[\n                                    \'defaultValue\']\n            if type[\'interfaces\']:\n                output[\'type\'][type[\'name\']][\'__implements\'] = {}\n                for iface in type[\'interfaces\']:\n                    output[\'type\'][type[\'name\']][\'__implements\'][iface[\'name\']] = {}\n\n            if \'type\' not in output[\'type\'][type[\'name\']] and \'args\' in output[\'type\'][type[\'name\']]:\n                output[\'type\'][type[\'name\']]["type"] = output[\'type\'][type[\'name\']]["args"]["type"]\n\n\n    # Get all the Enums\n    output[\'enum\'] = {}\n    for type in schema[\'types\']:\n        if type[\'name\'][0:2] == \'__\': continue\n        if type[\'kind\'] == \'ENUM\':\n            output[\'enum\'][type[\'name\']] = {}\n            for v in type[\'enumValues\']:\n                output[\'enum\'][type[\'name\']][v[\'name\']] = {}\n\n    # Get all the Scalars\n    output[\'scalar\'] = {}\n    for type in schema[\'types\']:\n        if type[\'name\'][0:2] == \'__\': continue\n        if type[\'kind\'] == \'SCALAR\' and type[\'name\'] not in [\'String\', \'Int\', \'Float\', \'Boolean\', \'ID\']:\n            output[\'scalar\'][type[\'name\']] = {}\n\n    # Get all the inputs\n    output[\'input\'] = {}\n    for type in schema[\'types\']:\n        if type[\'name\'][0:2] == \'__\': continue\n        if type[\'kind\'] == \'INPUT_OBJECT\':\n            output[\'input\'][type[\'name\']] = {}\n            if type[\'inputFields\']:\n                for field in type[\'inputFields\']:\n                    output[\'input\'][type[\'name\']][field[\'name\']] = {\n                        "type": _recursive_name_get(field[\'type\']),\n                        "required": field[\'type\'][\'kind\'] == \'NON_NULL\',\n                        "array": _recursive_kind_of(field[\'type\'], \'LIST\'),\n                    }\n\n    # Get all the unions\n    output[\'union\'] = {}\n    for type in schema[\'types\']:\n        if type[\'name\'][0:2] == \'__\': continue\n        if type[\'kind\'] == \'UNION\':\n            output[\'union\'][type[\'name\']] = {}\n            for v in type[\'possibleTypes\']:\n                output[\'union\'][type[\'name\']][v[\'name\']] = {}\n\n    # Get all the interfaces\n    output[\'interface\'] = {}\n    for type in schema[\'types\']:\n        if type[\'name\'][0:2] == \'__\': continue\n        if type[\'kind\'] == \'INTERFACE\':\n            output[\'interface\'][type[\'name\']] = {}\n            if type[\'fields\']:\n                for field in type[\'fields\']:\n                    output[\'interface\'][type[\'name\']][field[\'name\']] = {\n                        "type": _recursive_name_get(field[\'type\']),\n                        "required": field[\'type\'][\'kind\'] == \'NON_NULL\',\n                        "array": _recursive_kind_of(field[\'type\'], \'LIST\'),\n                    }\n                    if field[\'args\']:\n                        output[\'interface\'][type[\'name\']][field[\'name\']]["args"] = {}\n                        for arg in field[\'args\']:\n                            output[\'interface\'][type[\'name\']][field[\'name\']][\'args\'][arg[\'name\']] = {\n                                "type": _recursive_name_get(arg[\'type\']),\n                                "required": arg[\'type\'][\'kind\'] == \'NON_NULL\',\n                                "array": _recursive_kind_of(arg[\'type\'], \'LIST\'),\n                            }\n                            if arg[\'defaultValue\'] != None:\n                                output[\'interface\'][type[\'name\']][field[\'name\']][\'args\'][arg[\'name\']][\'default\'] = arg[\n                                    \'defaultValue\']\n            if \'type\' not in output[\'interface\'][type[\'name\']] and \'args\' in output[\'interface\'][type[\'name\']]:\n                output[\'interface\'][type[\'name\']]["type"] = output[\'interface\'][type[\'name\']]["args"]["type"]\n\n    return output\n\n\ndef raw_request(request):\n    """\n    At this point it is completely built and ready\n    to be fired; it is "prepared".\n\n    However pay attention at the formatting used in\n    this function because it is programmed to be pretty\n    printed and may differ from the actual request.\n    """\n    headers = request.headers.copy()\n    if \'Connection\' not in headers:\n        headers[\'Connection\'] = \'close\'\n    if \'User-Agent\' not in headers:\n        headers[\'User-Agent\'] = \'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0\'\n    if \'Accept-Encoding\' not in headers:\n        headers[\'Accept-Encoding\'] = \'gzip, deflate\'\n    url = urlparse(request.get_full_url())\n    headers[\'Host\'] = url.netloc\n    path = url.path if len(url.path) else \'/\'\n\n    return \'{}\\r\\n{}\\r\\n\\r\\n{}\'.format(\n        request.get_method() + \' \' + path + \' HTTP/1.1\',\n        \'\\r\\n\'.join(\'{}: {}\'.format(k, v) for k, v in headers.items()),\n        request.data if request.data else \'\',\n    )\n')
    __stickytape_write_module('inql/__init__.py', "\ntry:\n    from inql.__version__ import __version__\nexcept ImportError:\n    __version__ = 'undefined'")
    __stickytape_write_module('inql/__version__.py', "__version__ = '4.0.1'")
    __stickytape_write_module('inql/widgets/__init__.py', '')
    __stickytape_write_module('inql/burp_ext/__init__.py', '')
    __stickytape_write_module('inql/burp_ext/scanner.py', 'import platform\n\nif platform.system() != "Java":\n    print("Load this file inside jython, if you need the stand-alone tool run: inql")\n    exit(-1)\n\nfrom array import array\n\nfrom burp import IScanIssue, IScannerCheck\n\nfrom inql.constants import TECH_CHECKS, CONSOLE_CHECKS, URLS\n\n\nclass _CustomScanIssue(IScanIssue):\n    """\n    Custom Scan Issue Container\n    """\n    def __init__(self, http_service, url, http_messages, name, detail, severity, confidence, issuebg, rembg, remdet):\n        self._http_service = http_service\n        self._url = url\n        self._http_messages = http_messages\n        self._name = name\n        self._detail = detail\n        self._severity = severity\n        self._confidence = confidence\n        self._issuebg = issuebg\n        self._rembg = rembg\n        self._remdet = remdet\n\n    def getUrl(self):\n        """\n        Overrides IScanIssue\n\n        :return: the URL\n        """\n        return self._url\n\n    def getIssueName(self):\n        """\n        Overrides IScanIssue\n\n        :return: the Issue Name\n        """\n        return self._name\n\n    def getIssueType(self):\n        """\n        Overrides IScanIssue\n\n        See http://portswigger.net/burp/help/scanner_issuetypes.html\n\n        :return: always 0\n        """\n        return 0\n\n    def getSeverity(self):\n        """\n        Overrides IScanIssue\n\n        :return: "High", "Medium", "Low", "Information" or "False positive"\n        """\n        return self._severity\n\n    def getConfidence(self):\n        """\n        Overrides IScanIssue\n\n        :return: "Certain", "Firm" or "Tentative"\n        """\n        return self._confidence\n\n    def getIssueBackground(self):\n        """\n        Overrides IScanIssue\n\n        :return: issue background\n        """\n        return self._issuebg\n\n    def getRemediationBackground(self):\n        """\n        Overrides IScanIssue\n\n        :return: remediation background\n        """\n        return self._rembg\n\n    def getIssueDetail(self):\n        """\n        Overrides IScanIssue\n\n        :return: issue detail\n        """\n        return self._detail\n\n    def getRemediationDetail(self):\n        """\n        Overrides IScanIssue\n\n        :return: remediation detail\n        """\n        return self._remdet\n\n    def getHttpMessages(self):\n        """\n        Overrides IScanIssue\n\n        :return: Http messages content\n        """\n        return self._http_messages\n\n    def getHttpService(self):\n        """\n        Overrides IScanIssue\n\n        :return: Http Service\n        """\n        return self._http_service\n\n\nclass BurpScannerCheck(IScannerCheck):\n    """\n    Scanner Check\n    """\n    def __init__(self, callbacks):\n        self._callbacks = callbacks\n        self._helpers = callbacks.getHelpers()\n\n    def _get_matches(self, response, match):\n        """\n        helper method to search a response for occurrences of a literal match string\n        and return a list of start/end offsets.\n\n        :param response: response object to search for\n        :param match: search term\n        :return: matches\n        """\n        matches = []\n        start = 0\n        reslen = len(response)\n        matchlen = len(match)\n        while start < reslen:\n            """\n            indexOf(byte[] data, byte[] pattern, boolean caseSensitive, int from, int to)\n            This method searches a piece of data for the first occurrence of a specified pattern.\n            """\n            start = self._helpers.indexOf(response, match, False, start, reslen)\n            if start == -1:\n                break\n            matches.append(array(\'i\', [start, start + matchlen]))\n            start += matchlen\n\n        return matches\n\n    def doPassiveScan(self, baseRequestResponse):\n        """\n        Override IScannerCheck method.\n\n        :param baseRequestResponse: burp requestResponse message.\n        :return: issues containing all the burp findings, they will be added to the found issues.\n        """\n        issues = []\n        for check in TECH_CHECKS:\n            # look for matches of our passive check grep string\n            matches = self._get_matches(baseRequestResponse.getResponse(), bytearray(check))\n            if len(matches) != 0:\n                # report the issue\n                issues.extend([_CustomScanIssue(\n                    http_service=baseRequestResponse.getHttpService(),\n                    url=self._helpers.analyzeRequest(baseRequestResponse).getUrl(),\n                    http_messages=[self._callbacks.applyMarkers(baseRequestResponse, None, matches)],\n                    name="GraphQL Technology",\n                    detail="The website is using GraphQL Technology!<br><br>"\n                    "GraphQL is an open-source data query and manipulation language for APIs, and a runtime for fulfilling queries with existing data. GraphQL was developed internally by Facebook in 2012 before being publicly released in 2015.<br><br>"\n                    "It provides an efficient, powerful and flexible approach to developing web APIs, and has been compared and contrasted with REST and other web service architectures. It allows clients to define the structure of the data required, and exactly the same structure of the data is returned from the server, therefore preventing excessively large amounts of data from being returned, but this has implications for how effective web caching of query results can be. The flexibility and richness of the query language also adds complexity that may not be worthwhile for simple APIs. It consists of a type system, query language and execution semantics, static validation, and type introspection.<br><br>"\n                    "GraphQL supports reading, writing (mutating) and subscribing to changes to data (realtime updates).",\n                    severity="Information", confidence="Firm", issuebg="Not posing any imminent security risk.",\n                    rembg="<ul><li><a href=\'https://graphql.org/\'>GraphQL</a></li></ul>",\n                    remdet=""\n                )])\n\n        for check in CONSOLE_CHECKS:\n            # look for matches of our passive check grep string\n            matches = self._get_matches(baseRequestResponse.getResponse(), bytearray(check))\n            if len(matches) != 0:\n                # report the issue\n                issues.extend([_CustomScanIssue(\n                    http_service=baseRequestResponse.getHttpService(),\n                    url=self._helpers.analyzeRequest(baseRequestResponse).getUrl(),\n                    http_messages=[self._callbacks.applyMarkers(baseRequestResponse, None, matches)],\n                    name="Exposed GraphQL Development Console",\n                    detail="GraphQL is a query language for APIs and a runtime for fulfilling queries with existing data.<br><br>"\n                    "<b>GraphiQL/GraphQL Playground</b> are in-browser tools for writing, validating, and testing GraphQL queries.<br><br>"\n                    "The response contains the following string: <b>%s</b>." % check,\n                    severity="Low", confidence="Firm", issuebg="Not posing any imminent security risk.",\n                    rembg="<ul>"\n                    "<li><a href=\'https://graphql.org/\'>GraphQL</a></li>"\n                    "<li><a href=\'https://github.com/graphql/graphiql\'>GraphiQL</a></li>"\n                    "<li><a href=\'https://github.com/prisma/graphql-playground\'>GraphQL Playground</a></li>"\n                    "</ul>",\n                    remdet="Remove the GraphQL development console from web-application in a production stage.<br><br>"\n                    "Disable GraphiQL<br>"\n                    "<pre>if (process.env.NODE_ENV === \'development\') {</pre></br>"\n                    "<pre>  app.all(</pre></br>"\n                    "<pre>    \'/graphiql\',</pre></br>"\n                    "<pre>    graphiqlExpress({</pre></br>"\n                    "<pre>      endpointURL: \'/graphql\',</pre></br>"\n                    "<pre>    }),</pre></br>"\n                    "<pre>  );</pre></br>"\n                    "<pre>}</pre>"\n                )])\n\n        return issues\n\n    def doActiveScan(self, baseRequestResponse, insertionPoint):\n        """\n        Override IScannerCheck method.\n\n        :param baseRequestResponse: burp requestResponse message.\n        :param insertionPoint: where to insert the payload, never used\n        :return: issues containing all the burp findings, they will be added to the found issues.\n        """\n\n        issues = []\n        # will request the URLS, passive scanner will do the grep and match\n        for url in URLS:\n            path = self._callbacks.getHelpers().analyzeRequest(baseRequestResponse).getUrl().getPath()\n            # replace the path inside the old bytearray for the new request\n            newReq = self._callbacks.getHelpers().bytesToString(baseRequestResponse.getRequest()).replace(path, url,\n                                                                                                          1)\n            result = self._callbacks.makeHttpRequest(baseRequestResponse.getHttpService(), newReq)\n            for check in TECH_CHECKS:\n                # look for matches of our passive check grep string\n                matches = self._get_matches(result.getResponse(), bytearray(check))\n                if len(matches) != 0:\n                    # report the issue\n                    issues.extend([_CustomScanIssue(\n                        http_service=result.getHttpService(),\n                        url=self._helpers.analyzeRequest(result).getUrl(),\n                        http_messages=[self._callbacks.applyMarkers(result, None, matches)],\n                        name="GraphQL Technology",\n                        detail="The website is using GraphQL Technology!<br><br>"\n                        "GraphQL is an open-source data query and manipulation language for APIs, and a runtime for fulfilling queries with existing data. GraphQL was developed internally by Facebook in 2012 before being publicly released in 2015.<br><br>"\n                        "It provides an efficient, powerful and flexible approach to developing web APIs, and has been compared and contrasted with REST and other web service architectures. It allows clients to define the structure of the data required, and exactly the same structure of the data is returned from the server, therefore preventing excessively large amounts of data from being returned, but this has implications for how effective web caching of query results can be. The flexibility and richness of the query language also adds complexity that may not be worthwhile for simple APIs. It consists of a type system, query language and execution semantics, static validation, and type introspection.<br><br>"\n                        "GraphQL supports reading, writing (mutating) and subscribing to changes to data (realtime updates).",\n                        severity="Information", confidence="Firm", issuebg="Not posing any imminent security risk.",\n                        rembg="<ul><li><a href=\'https://graphql.org/\'>GraphQL</a></li></ul>",\n                        remdet=""\n                    )])\n\n            for check in CONSOLE_CHECKS:\n                # look for matches of our passive check grep string\n                matches = self._get_matches(result.getResponse(), bytearray(check))\n                if len(matches) != 0:\n                    # report the issue\n                    issues.extend([_CustomScanIssue(\n                        http_service=result.getHttpService(),\n                        url=self._helpers.analyzeRequest(result).getUrl(),\n                        http_messages=[self._callbacks.applyMarkers(result, None, matches)],\n                        name="Exposed GraphQL Development Console",\n                        detail="GraphQL is a query language for APIs and a runtime for fulfilling queries with existing data.<br><br>"\n                        "<b>GraphiQL/GraphQL Playground</b> are in-browser tools for writing, validating, and testing GraphQL queries.<br><br>"\n                        "The response contains the following string: <b>%s</b>." % check,\n                        severity="Low", confidence="Firm", issuebg="Not posing any imminent security risk.",\n                        rembg="<ul>"\n                        "<li><a href=\'https://graphql.org/\'>GraphQL</a></li>"\n                        "<li><a href=\'https://github.com/graphql/graphiql\'>GraphiQL</a></li>"\n                        "<li><a href=\'https://github.com/prisma/graphql-playground\'>GraphQL Playground</a></li>"\n                        "</ul>",\n                        remdet="Remove the GraphQL development console from web-application in a production stage.<br><br>"\n                        "Disable GraphiQL<br>"\n                        "<pre>if (process.env.NODE_ENV === \'development\') {</pre></br>"\n                        "<pre>  app.all(</pre></br>"\n                        "<pre>    \'/graphiql\',</pre></br>"\n                        "<pre>    graphiqlExpress({</pre></br>"\n                        "<pre>      endpointURL: \'/graphql\',</pre></br>"\n                        "<pre>    }),</pre></br>"\n                        "<pre>  );</pre></br>"\n                        "<pre>}</pre>"\n                    )])\n\n        return issues\n\n    def consolidateDuplicateIssues(self, existingIssue, newIssue):\n        """\n        This method is called when multiple issues are reported for the same URL\n        path by the same extension-provided check. The value we return from this\n        method determines how/whether Burp consolidates the multiple issues\n        to prevent duplication\n\n        Do not report same issues on the same path\n\n        :param existingIssue: an issue we have already saved\n        :param newIssue: an issue we are gonna insert\n        :return: 0 if the issue as to be inserted, -1 otherwise\n        """\n\n        if (existingIssue.getHttpMessages()[0].getHttpService().getHost() == newIssue.getHttpMessages()[\n            0].getHttpService().getHost()) and (\n                existingIssue.getHttpMessages()[0].getHttpService().getPort() == newIssue.getHttpMessages()[\n            0].getHttpService().getPort()):\n            return -1\n        else:\n            return 0')
    __stickytape_write_module('inql/constants.py', 'SCANNER_VERSION = \'%%VERSION%%\'\n\nTECH_CHECKS = {\n    \'{"data":{"__schema":{\',\n    "graphql-ws"\n}\n\nCONSOLE_CHECKS = {\n    "GraphiQL",\n    "GraphQL Playground",\n    "GraphQL Console",\n    "graphql-playground"\n}\n\nURLS = {\n    "/graphql.php",\n    "/graphql",\n    "/graphiql",\n    "/graphql/console/",\n    "/swapi-graphql/",\n    "/gql",\n    "/graphql/subscriptions",\n    "/graphql/subscription"\n}\n\nDEFAULT_LOAD_URL = "URL or File Location (eg: http://example.com/graphql or /tmp/schema.json)"')
    __stickytape_write_module('inql/burp_ext/generator_tab.py', 'from __future__ import print_function\n\nimport platform\n\nif platform.system() != "Java":\n    print("Load this file inside jython, if you need the stand-alone tool run: inql")\n    exit(-1)\n\nimport json\n\nfrom burp import ITab\n\nfrom inql.actions.sendto import SendToAction\nfrom inql.burp_ext.contextual import BurpHTTPMutator as HTTPMutator, OmniMenuItem\nfrom inql.actions.setcustomheader import CustomHeaderSetterAction\nfrom inql.widgets.generator import GeneratorPanel\n\n\nclass GeneratorTab(ITab):\n    """\n    Java GUI\n    """\n    def __init__(self, callbacks, helpers):\n        self._callbacks = callbacks\n        self._helpers = helpers\n        self.disable_http2()\n\n    def getTabCaption(self):\n        """\n        Override ITab method\n        :return: tab name\n        """\n        return "InQL Scanner"\n\n    def getUiComponent(self):\n        """\n        Override ITab method\n        :return: Tab UI Component\n        """\n        overrideheaders = {}\n\n        repeater_omnimenu = OmniMenuItem(callbacks=self._callbacks, helpers=self._helpers, text="Send to Repeater")\n        repeater_get_omnimenu = OmniMenuItem(callbacks=self._callbacks, helpers=self._helpers,\n                                             text="Send to Repeater (GET - Query Params)")\n        repeater_post_urlencoded_omnimenu = OmniMenuItem(callbacks=self._callbacks, helpers=self._helpers,\n                                              text="Send to Repeater (POST - Body URLEncoded)")\n        repeater_post_formdata_omnimenu = OmniMenuItem(callbacks=self._callbacks, helpers=self._helpers,\n                                              text="Send to Repeater (POST - Body form-data)")\n        graphiql_omnimenu = OmniMenuItem(callbacks=self._callbacks, helpers=self._helpers, text="Send to GraphiQL")\n\n        http_mutator = HTTPMutator(\n            callbacks=self._callbacks, helpers=self._helpers, overrideheaders=overrideheaders)\n\n        repeater_sender = SendToAction(omnimenu=repeater_omnimenu, has_host=http_mutator.has_host,\n                                       send_to=http_mutator.send_to_repeater)\n        repeater_get_sender = SendToAction(omnimenu=repeater_get_omnimenu, has_host=http_mutator.has_host,\n                                           send_to=http_mutator.send_to_repeater_get_query)\n        repeater_post_urlencoded_sender = SendToAction(omnimenu=repeater_post_urlencoded_omnimenu, has_host=http_mutator.has_host,\n                                            send_to=http_mutator.send_to_repeater_post_urlencoded_body)\n        repeater_post_form_data_sender = SendToAction(omnimenu=repeater_post_formdata_omnimenu, has_host=http_mutator.has_host,\n                                            send_to=http_mutator.send_to_repeater_post_form_data_body)\n        graphiql_sender = SendToAction(omnimenu=graphiql_omnimenu, has_host=http_mutator.has_host,\n                                       send_to=http_mutator.send_to_graphiql)\n\n        custom_header_setter = CustomHeaderSetterAction(overrideheaders=overrideheaders, text="Set Custom Header")\n        try:\n            restore = self._callbacks.loadExtensionSetting(GeneratorPanel.__name__)\n        except Exception as ex:\n            print("Cannot restore state! %s" % ex)\n            restore = None\n\n        proxy = None\n\n        for request_listener in json.loads(self._callbacks.saveConfigAsJson())["proxy"]["request_listeners"]:\n            if request_listener["running"]:\n                proxy = "localhost:%s" % request_listener["listener_port"]\n                break\n\n        self.panel = GeneratorPanel(\n            actions=[\n                repeater_sender,\n                repeater_get_sender,\n                repeater_post_urlencoded_sender,\n                repeater_post_form_data_sender,\n                graphiql_sender,\n                custom_header_setter],\n            restore=restore,\n            proxy=proxy,\n            http_mutator=http_mutator,\n            texteditor_factory=self._callbacks.createTextEditor\n        )\n        self._callbacks.customizeUiComponent(self.panel.this)\n        return self.panel.this\n\n    def disable_http2(self):\n        try:\n            print("Jython does not support HTTP/2 at the current stage: disabling it!")\n            j = json.loads(self._callbacks.saveConfigAsJson())\n            j[\'project_options\'][\'http\'][\'http2\'][\'enable_http2\'] = False\n            self._callbacks.loadConfigFromJson(json.dumps(j))\n        except Exception as ex:\n            print("Cannot disable HTTP/2! %s" % ex)\n\n    def bring_in_front(self):\n        self.panel.this.setAlwaysOnTop(True)\n        self.panel.this.setAlwaysOnTop(False)\n\n    def save(self):\n        """\n        Save Extension State before exiting\n        :return: None\n        """\n        try:\n            self._callbacks.saveExtensionSetting(self.panel.__class__.__name__, self.panel.state())\n        except:\n            print("Cannot save state!")')
    __stickytape_write_module('inql/actions/sendto.py', 'import platform\n\nif platform.system() != "Java":\n    print("Load this file inside jython, if you need the stand-alone tool run: inql")\n    exit(-1)\n\ntry:\n    from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer\nexcept ImportError:\n    from http.server import BaseHTTPRequestHandler, HTTPServer\n\ntry:\n    import urllib.request as urllib_request # for Python 3\n    from urllib.parse import urlencode\nexcept ImportError:\n    import urllib2 as urllib_request # for Python 2 and Jython\n    from urllib import urlencode\n\nimport json\nimport threading\n\nfrom java.awt.event import ActionListener\nfrom javax.swing import JMenuItem\n\ntry:\n    from burp import IContextMenuFactory\nexcept ImportError:\n    IContextMenuFactory = object\n\nfrom inql.actions.browser import URLOpener\nfrom inql.utils import make_http_handler, HTTPRequest\n\n\nclass SimpleMenuItem:\n    """\n    An OmniMenuItem implemented on top of a single item entry.\n    """\n    def __init__(self, text=None):\n        self.menuitem = JMenuItem(text)\n        self.menuitem.setEnabled(False)\n\n    def add_action_listener(self, action_listener):\n        self.menuitem.addActionListener(action_listener)\n\n    def set_enabled(self, enabled):\n        self.menuitem.setEnabled(enabled)\n\n\nclass SendToAction(ActionListener):\n    """\n    Class represeintg the action of sending something to BURP Repeater\n    """\n    def __init__(self, omnimenu, has_host, send_to):\n        self._has_host = has_host\n        self._send_to = send_to\n        self._omnimenu = omnimenu\n        self._omnimenu.add_action_listener(self)\n        self.menuitem = self._omnimenu.menuitem\n        self._host = None\n        self._payload = None\n        self._fname = None\n\n    def actionPerformed(self, e):\n        """\n        Overrides ActionListener behaviour. Send current query to repeater.\n\n        :param e: unused\n        :return: None\n        """\n        self._send_to(self._host, self._payload)\n\n    def ctx(self, host=None, payload=None, fname=None):\n        """\n        When a fname is specified and is a query file or a request is selected in the other tabs,\n        enables the context menu to send to repeater tab\n\n        :param host: should be not null\n        :param payload: should be not null\n        :param fname: should be not null\n        :return: None\n        """\n        self._host = host\n        self._payload = payload\n        self._fname = fname\n\n        if not self._fname.endswith(\'.query\'):\n            self._omnimenu.set_enabled(False)\n            return\n\n        if self._has_host(host):\n            self._omnimenu.set_enabled(True)\n        else:\n            self._omnimenu.set_enabled(False)\n\n\nclass HTTPMutator(object):\n    """\n    An implementation of an HTTPMutater which employs the Burp Utilities to enhance the requests\n    """\n    def __init__(self, overrideheaders=None, requests=None, stub_responses=None):\n        self._requests = requests if requests is not None else {}\n        self._overrideheaders = overrideheaders if overrideheaders is not None else {}\n        self._overrideheaders = overrideheaders if overrideheaders is not None else {}\n        self._index = 0\n        self._stub_responses = stub_responses if stub_responses is not None else {}\n\n        # Register GraphIQL Server\n        self._server = HTTPServer((\'127.0.0.1\', 0), make_http_handler(self))\n        t = threading.Thread(target=self._server.serve_forever)\n        #t.daemon = True\n        t.start()\n\n\n    def get_graphiql_target(self, server_port, host=None, query=None, variables=None):\n        base_url = "http://localhost:%s/%s" % (server_port, self._requests[host][\'url\'])\n        arguments = ""\n        if query or variables:\n            arguments += \'?\'\n            args = []\n            if host:\n                args.append("query=%s" % urllib_request.quote(query))\n            if variables:\n                args.append("variables=%s" % urllib_request.quote(json.dumps(variables)))\n            arguments += "&".join(args)\n\n        return base_url + arguments\n\n    def has_host(self, host):\n        try:\n            self._requests[host]\n            return True\n        except KeyError:\n            return False\n\n    def build_python_request(self, endpoint, host, payload):\n        req = self._requests[host][\'POST\'] or self._requests[host][\'PUT\'] or self._requests[host][\'GET\']\n        if req:\n            original_request = HTTPRequest(req[1])\n            del original_request.headers[\'Content-Length\']\n\n            # TODO: Implement custom headers in threads. It is not easy to share them with the current architecture.\n            return urllib_request.Request(endpoint, payload, headers=original_request.headers)\n\n    def get_stub_response(self, host):\n        return self._stub_responses[host] if host in self._stub_responses else None\n\n    def set_stub_response(self, host, payload):\n        self._stub_responses[host] = payload\n\n    def send_to_graphiql(self, host, payload):\n        content = json.loads(payload)\n        if isinstance(content, list):\n            content = content[0]\n\n        URLOpener().open(self.get_graphiql_target(\n            self._server.server_port, host,\n            content[\'query\'] if \'query\' in content else None,\n            content[\'variables\'] if \'variables\' in content else None))')
    __stickytape_write_module('inql/actions/browser.py', 'import platform\n\nif platform.system() != "Java":\n    print("Load this file inside jython, if you need the stand-alone tool run: inql")\n    exit(-1)\n\nimport subprocess\nimport os\n\nfrom java.awt.event import ActionListener\nfrom java.awt import Desktop\nfrom javax.swing import JMenuItem\nfrom java.net import URI\n\n\nclass URLOpener():\n    """\n    Open URLs on any major operative system (macOS, Linux XDG and Windows).\n    """\n    def __init__(self):\n        self.openers = [\n            lambda url: Desktop.getDesktop().browse(URI(url)),\n            lambda url: subprocess.call(["xdg-open", url]),\n            lambda url: subprocess.call(["open", url])\n        ]\n\n    def open(self, url):\n        """\n        Try to execute the first available browser. Since on every system (Darwin, Windows and Linux) this procedure is\n        different, iterate on every procedure and exit on the first successful one or on the last one altogether.\n\n        :param url: url to be opened\n        :return: None\n        """\n        for opener in self.openers:\n            try:\n                opener(url)\n                return\n            except:\n                pass\n        print("Cannot open url %s!!!" % url)\n\n\nclass BrowserAction(ActionListener):\n    """\n    BrowserAction performs a new "Open In Browser" action when the context is set to an HTML File.\n    The idea is to show HTML documentation in a Browser, when generated and the context is correct\n    """\n\n    def __init__(self, text="Open In Browser"):\n        self.menuitem = JMenuItem(text)\n        self.menuitem.setEnabled(False)\n        self.menuitem.addActionListener(self)\n\n    def actionPerformed(self, e):\n        """\n        Override the ActionListener method. Usually setup in combination with a menuitem click.\n        :param e: unused\n        :return:\n        """\n        URLOpener().open("file://%s" % self.target)\n\n    def ctx(self, host=None, payload=None, fname=None):\n        """\n        Setup the current context\n        :param host: unused\n        :param payload: unused\n        :param fname: filename of the selected file\n        :return: None\n        """\n        self.target = os.path.abspath(fname)\n        if self.target.endswith(\'.html\'):\n            self.menuitem.setEnabled(True)\n        else:\n            self.menuitem.setEnabled(False)')
    __stickytape_write_module('inql/actions/__init__.py', '')
    __stickytape_write_module('inql/burp_ext/contextual.py', 'import json\n\ntry:\n    import urllib.request as urllib_request # for Python 3\n    from urllib.parse import urlencode\nexcept ImportError:\n    import urllib2 as urllib_request # for Python 2 and Jython\n    from urllib import urlencode\n\nfrom java.awt.event import ActionListener\nfrom javax.swing import JMenuItem\n\nfrom org.python.core.util import StringUtil\n\nfrom burp import IProxyListener, IContextMenuFactory\n\nfrom inql.actions.sendto import HTTPMutator\nfrom inql.utils import is_query, override_headers, string_join, override_uri, clean_dict, multipart, random_string, \\\n    querify, json_encode\n\n\nclass OmniMenuItem(IContextMenuFactory):\n    """Menu item for burp and inql interface. IT contains same action but it is shown in multiple places"""\n    def __init__(self, helpers=None, callbacks=None, text=\'\'):\n        self._helpers = helpers\n        self._callbacks = callbacks\n        self.menuitem = JMenuItem(text)\n        self._burp_menuitem = JMenuItem("inql: %s" % text)\n        self.set_enabled(False)\n        self._callbacks.registerContextMenuFactory(self)\n\n    def add_action_listener(self, action_listener):\n        """\n        add a new action listener to the given UI items.\n        """\n        self._action_listener = action_listener\n        self.menuitem.addActionListener(action_listener)\n        self._burp_menuitem.addActionListener(action_listener)\n\n    def set_enabled(self, enabled):\n        """\n        Enables or disables the menuitme\n        """\n        self.menuitem.setEnabled(enabled)\n        self._burp_menuitem.setEnabled(enabled)\n\n    def createMenuItems(self, invocation):\n        """\n        Overrides IContextMenuFactory callback\n\n        :param invocation: handles menu selected invocation\n        :return:\n        """\n        try:\n            r = invocation.getSelectedMessages()[0]\n            info = self._helpers.analyzeRequest(r)\n            url = str(info.getUrl())\n            body = r.getRequest()[info.getBodyOffset():].tostring()\n            if not is_query(body):\n                return None\n            for h in info.getHeaders():\n                if h.lower().startswith("host:"):\n                    domain = h[5:].strip()\n\n            self._action_listener.ctx(fname=\'dummy.query\', host=domain, payload=body)\n            mymenu = []\n            mymenu.append(self._burp_menuitem)\n        except Exception as ex:\n            return None\n        return mymenu\n\n\nclass BurpHTTPMutator(HTTPMutator, IProxyListener):\n    def __init__(self, callbacks=None, helpers=None, overrideheaders=None, requests=None, stub_responses=None):\n        super(BurpHTTPMutator, self).__init__(overrideheaders=overrideheaders, requests=requests, stub_responses=stub_responses)\n\n        if helpers and callbacks:\n            self._helpers = helpers\n            self._callbacks = callbacks\n            self._callbacks.registerProxyListener(self)\n            for r in self._callbacks.getProxyHistory():\n                self._process_request(self._helpers.analyzeRequest(r), r.getRequest())\n\n    def _process_request(self, reqinfo, reqbody):\n        """\n        Process request and extract key values\n\n        :param reqinfo:\n        :param reqbody:\n        :return:\n        """\n        url = str(reqinfo.getUrl())\n        if is_query(reqbody[reqinfo.getBodyOffset():].tostring()):\n            for h in reqinfo.getHeaders():\n                if h.lower().startswith("host:"):\n                    domain = h[5:].strip()\n\n            method = reqinfo.getMethod()\n            try:\n                self._requests[domain]\n            except KeyError:\n                self._requests[domain] = {\'POST\': None, \'PUT\': None, \'GET\': None, \'url\': None}\n            self._requests[domain][method] = (reqinfo, reqbody)\n            self._requests[domain][\'url\'] = url\n\n    def processProxyMessage(self, messageIsRequest, message):\n        """\n        Implements IProxyListener method\n\n        :param messageIsRequest: True if BURP Message is a request\n        :param message: message content\n        :return: None\n        """\n        if self._helpers and self._callbacks and messageIsRequest:\n            self._process_request(self._helpers.analyzeRequest(message.getMessageInfo()),\n                                  message.getMessageInfo().getRequest())\n\n    def send_to_repeater(self, host, payload):\n        req = self._requests[host][\'POST\'] or self._requests[host][\'PUT\'] or self._requests[host][\'GET\']\n        if req and self._callbacks and self._helpers:\n            info = req[0]\n            body = req[1]\n            nobody = body[:info.getBodyOffset()].tostring()\n            rstripoffset = info.getBodyOffset()-len(nobody.rstrip())\n            headers = body[:info.getBodyOffset()-rstripoffset].tostring()\n\n            try:\n                self._overrideheaders[host]\n            except KeyError:\n                self._overrideheaders[host] = []\n\n            headers = override_headers(headers, self._overrideheaders[host])\n            repeater_body = StringUtil.toBytes(string_join(\n                headers,\n                body[info.getBodyOffset()-rstripoffset:info.getBodyOffset()].tostring(),\n                payload))\n\n            self._callbacks.sendToRepeater(info.getUrl().getHost(), info.getUrl().getPort(),\n                                           info.getUrl().getProtocol() == \'https\', repeater_body,\n                                          \'GraphQL #%s\' % self._index)\n            self._index += 1\n\n    def send_to_repeater_get_query(self, host, payload):\n        req = self._requests[host][\'POST\'] or self._requests[host][\'PUT\'] or self._requests[host][\'GET\']\n        if req and self._callbacks and self._helpers:\n            info = req[0]\n            body = req[1]\n            nobody = body[:info.getBodyOffset()].tostring()\n            rstripoffset = info.getBodyOffset()-len(nobody.rstrip())\n            metadata = body[:info.getBodyOffset()-rstripoffset].tostring()\n\n            try:\n                self._overrideheaders[host]\n            except KeyError:\n                self._overrideheaders[host] = []\n\n            metadata = override_headers(metadata, self._overrideheaders[host])\n            content = json.loads(payload)\n            if isinstance(content, list):\n                content = content[0]\n            metadata = override_uri(metadata, method="GET", query=urlencode(json_encode(clean_dict(content))))\n\n            repeater_body = StringUtil.toBytes(string_join(\n                metadata,\n                body[info.getBodyOffset()-rstripoffset:info.getBodyOffset()].tostring()))\n\n            self._callbacks.sendToRepeater(info.getUrl().getHost(), info.getUrl().getPort(),\n                                           info.getUrl().getProtocol() == \'https\', repeater_body,\n                                          \'GraphQL - GET query #%s\' % self._index)\n            self._index += 1\n\n    def send_to_repeater_post_urlencoded_body(self, host, payload):\n        req = self._requests[host][\'POST\'] or self._requests[host][\'PUT\'] or self._requests[host][\'GET\']\n        if req and self._callbacks and self._helpers:\n            info = req[0]\n            body = req[1]\n            nobody = body[:info.getBodyOffset()].tostring()\n            rstripoffset = info.getBodyOffset()-len(nobody.rstrip())\n            headers = body[:info.getBodyOffset()-rstripoffset].tostring()\n\n            try:\n                self._overrideheaders[host]\n            except KeyError:\n                self._overrideheaders[host] = []\n\n            headers = override_headers(headers, self._overrideheaders[host])\n            headers = override_headers(headers, [("Content-Type", "application/x-www-form-urlencoded")])\n            headers = override_uri(headers, method="POST")\n            content = json.loads(payload)\n            if isinstance(content, list):\n                content = content[0]\n            repeater_body = StringUtil.toBytes(string_join(\n                headers,\n                body[info.getBodyOffset()-rstripoffset:info.getBodyOffset()].tostring(),\n                urlencode(querify(clean_dict(content)))))\n\n            self._callbacks.sendToRepeater(info.getUrl().getHost(), info.getUrl().getPort(),\n                                           info.getUrl().getProtocol() == \'https\', repeater_body,\n                                          \'GraphQL - POST urlencoded #%s\' % self._index)\n            self._index += 1\n\n    def send_to_repeater_post_form_data_body(self, host, payload):\n        req = self._requests[host][\'POST\'] or self._requests[host][\'PUT\'] or self._requests[host][\'GET\']\n        if req and self._callbacks and self._helpers:\n            info = req[0]\n            body = req[1]\n            nobody = body[:info.getBodyOffset()].tostring()\n            rstripoffset = info.getBodyOffset()-len(nobody.rstrip())\n            headers = body[:info.getBodyOffset()-rstripoffset].tostring()\n\n            try:\n                self._overrideheaders[host]\n            except KeyError:\n                self._overrideheaders[host] = []\n\n            headers = override_headers(headers, self._overrideheaders[host])\n            boundary = "---------------------------%s" % random_string()\n            headers = override_headers(headers, [("Content-Type", "multipart/form-data, boundary=%s" % boundary)])\n            headers = override_uri(headers, method="POST")\n            content = json.loads(payload)\n            if isinstance(content, list):\n                content = content[0]\n            repeater_body = StringUtil.toBytes(string_join(\n                headers,\n                body[info.getBodyOffset()-rstripoffset:info.getBodyOffset()].tostring(),\n                multipart(data=querify(clean_dict(content)), boundary=boundary)))\n\n            self._callbacks.sendToRepeater(info.getUrl().getHost(), info.getUrl().getPort(),\n                                           info.getUrl().getProtocol() == \'https\', repeater_body,\n                                          \'GraphQL - POST form-data #%s\' % self._index)\n            self._index += 1')
    __stickytape_write_module('inql/actions/setcustomheader.py', 'from __future__ import print_function\nimport platform\n\nif platform.system() != "Java":\n    print("Load this file inside jython, if you need the stand-alone tool run: inql")\n    exit(-1)\n\nfrom java.awt.event import ActionListener\nfrom javax.swing import JMenuItem\n\nfrom inql.widgets.propertyeditor import PropertyEditor\n\n\nclass CustomHeaderSetterAction(ActionListener):\n    """\n    Set Custom Header Action\n    """\n\n    def __init__(self, overrideheaders, text="Set Custom Header"):\n        self.requests = {}\n        self.menuitem = JMenuItem(text)\n        self.menuitem.setEnabled(False)\n        self.menuitem.addActionListener(self)\n        self._overrideheaders = overrideheaders\n        self._host = None\n\n    def actionPerformed(self, e):\n        """\n        Overrides ActionListener behaviour, when clicked it opens the headers property editor for the given host.\n\n        :param e: unused\n        :return:\n        """\n        if self._host:\n            try:\n                self._overrideheaders[self._host]\n            except KeyError:\n                print("No custom header for %s, generating an empty set" % self._host)\n                self._overrideheaders[self._host] = []\n            PropertyEditor.get_instance("Set Custom Header for %s" % self._host,\n                           columns=["Header", "Value"],\n                           data=self._overrideheaders[self._host],\n                           empty=["X-New-Header", "X-New-Header-Value"])\n\n    def ctx(self, host=None, payload=None, fname=None):\n        """\n        implements the context setting behaviour\n\n        :param host: when host is not null set it and enable the menuitem.\n        :param payload: ignored\n        :param fname: ignored\n        :return:\n        """\n        if host:\n            self.menuitem.setEnabled(True)\n        else:\n            self.menuitem.setEnabled(False)\n        self._host = host\n')
    __stickytape_write_module('inql/widgets/propertyeditor.py', 'import platform\n\nif platform.system() != "Java":\n    print("Load this file inside jython, if you need the stand-alone tool run: inql")\n    exit(-1)\n\nimport time\n\nfrom javax.swing import JFrame, JTable, JScrollPane, JPopupMenu\nfrom java.awt import Color\nfrom javax.swing.table import DefaultTableModel\nfrom java.awt.event import WindowAdapter\n\nfrom inql.actions.executor import ExecutorAction\nfrom inql.utils import inherits_popup_menu\n\nclass PropertyEditor(WindowAdapter):\n    """\n    Edits Tabular Properties of a given WindowAdapter\n    """\n    instances = {}\n    last_location = None\n    locations = {}\n    last_size = None\n    sizes = {}\n\n    NEW_WINDOW_OFFSET = 32\n    offset = NEW_WINDOW_OFFSET\n\n    @staticmethod\n    def get_instance(text="Property Editor", columns=None, data=None, empty=None, add_actions=True, actions=None):\n        """\n        Singleton Method based on the text property. It tries to generate only one property configuration page per text.\n\n        :param text: getinstance key\n        :param columns: proparty columns it should be an array alike\n        :param data: it contains the current property rows\n        :param empty: empty row property when adding a new one\n        :param add_actions: include or not new actions\n        :param actions: default set of actions to be appended to Add and Delete Rows\n        :return: a new instance of PropertyEditor or a reused one.\n        """\n        if not actions: actions = []\n        if not columns: columns = []\n        if data == None: data = []\n        if not empty: empty = []\n        try:\n            PropertyEditor.instances[text]\n        except KeyError:\n            PropertyEditor.instances[text] = \\\n                PropertyEditor().__private_init__(text, columns, data, empty, add_actions, actions)\n            try:\n                PropertyEditor.instances[text].this.setLocation(PropertyEditor.locations[text])\n            except KeyError:\n                if PropertyEditor.last_location:\n                    PropertyEditor.instances[text].this.setLocation(\n                        PropertyEditor.last_location.x+PropertyEditor.offset,\n                        PropertyEditor.last_location.y+PropertyEditor.offset)\n                    PropertyEditor.offset = PropertyEditor.NEW_WINDOW_OFFSET\n            try:\n                PropertyEditor.instances[text].this.setSize(PropertyEditor.sizes[text])\n            except KeyError:\n                if PropertyEditor.last_size:\n                    PropertyEditor.instances[text].this.setSize(PropertyEditor.last_size)\n            PropertyEditor.last_location = PropertyEditor.instances[text].this.getLocation()\n            PropertyEditor.last_size = PropertyEditor.instances[text].this.getSize()\n        ## Hack ON: Bring on Front\n        PropertyEditor.instances[text].this.setAlwaysOnTop(True)\n        PropertyEditor.instances[text].this.setAlwaysOnTop(False)\n        ## Hack OFF\n        return PropertyEditor.instances[text]\n\n    def __private_init__(self, text="Property Editor", columns=None, data=None, empty=None, add_actions=True, actions=None):\n        if not actions: actions = []\n        if not columns: columns = []\n        if data == None: data = []\n        if not empty: empty = []\n\n        self._text = text\n        self.this = JFrame(text)\n        self._table = JTable()\n        self._dtm = DefaultTableModel(0, 0)\n        self._dtm.setColumnIdentifiers(columns)\n        self._table.setModel(self._dtm)\n        self._data = data\n        for d in data:\n            self._dtm.addRow(d)\n        self._pane = JScrollPane(self._table)\n        self.this.add(self._pane)\n        self._empty = empty\n\n        self.this.addWindowListener(self)\n\n        self._dtm.addTableModelListener(lambda _: self._update_model())\n        self.this.setLocation(PropertyEditor.NEW_WINDOW_OFFSET, PropertyEditor.NEW_WINDOW_OFFSET)\n\n        if add_actions:\n            self._popup = JPopupMenu()\n            self._pane.setComponentPopupMenu(self._popup)\n            inherits_popup_menu(self._pane)\n\n            self._actions = actions\n            self._actions.append(ExecutorAction(\'Remove Selected Rows\', action=lambda e: self._remove_row()))\n            self._actions.append(ExecutorAction(\'Add New Row\', action=lambda e: self._add_row()))\n\n            for action in self._actions:\n                self._popup.add(action.menuitem)\n\n        self.this.setForeground(Color.black)\n        self.this.setBackground(Color.lightGray)\n        self.this.pack()\n        self.this.setVisible(True)\n        self.this.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE)\n\n        return self\n\n    def _add_row(self):\n        """\n        Add a new row the selection\n\n        :return: None\n        """\n        self._dtm.addRow(self._empty)\n\n    def _remove_row(self):\n        """\n        Remove all the selected rows from the selection\n        :return:\n        """\n        rows = self._table.getSelectedRows()\n        for i in range(0, len(rows)):\n            self._dtm.removeRow(rows[i] - i)\n\n    def windowClosing(self, evt):\n        """\n        Overrides WindowAdapter method\n\n        :param evt: unused\n        :return: None\n        """\n        PropertyEditor.locations[self._text] = self.this.getLocation()\n        PropertyEditor.sizes[self._text] = self.this.getSize()\n        PropertyEditor.last_location = self.this.getLocation()\n        PropertyEditor.last_size = self.this.getSize()\n        PropertyEditor.offset = 0\n        self.this.setVisible(False)\n        self.this.dispose()\n        del PropertyEditor.instances[self._text]\n\n    def _update_model(self):\n        """\n        Update the data content with the updated rows\n\n        :return: None\n        """\n        del self._data[:]\n        nRow = self._dtm.getRowCount()\n        nCol = self._dtm.getColumnCount()\n        for i in range(0, nRow):\n            self._data.append([None] * nCol)\n            for j in range(0, nCol):\n                d = str(self._dtm.getValueAt(i, j)).lower()\n                if d == \'none\' or d == \'\':\n                    self._data[i][j] = None\n                elif d == \'true\' or d == \'t\':\n                    self._data[i][j] = True\n                elif d == \'false\' or d == \'f\':\n                    self._data[i][j] = False\n                else:\n                    try:\n                        self._data[i][j] = int(self._dtm.getValueAt(i, j))\n                    except ValueError:\n                        self._data[i][j] = self._dtm.getValueAt(i, j)\n\nif __name__ == "__main__":\n    data = [[\'a\', \'b\'], [\'c\', \'d\']]\n    pe = PropertyEditor.get_instance(columns=[\'ciao\', \'bao\'], data=data, empty=[\'e1\', \'e2\'])\n    while True:\n        time.sleep(10)\n        pe = PropertyEditor.get_instance(columns=[\'ciao\', \'bao\'], data=data, empty=[\'e1\', \'e2\'])\n        PropertyEditor.get_instance(text=\'test2\', columns=[\'ciao\', \'bao\'], data=data, empty=[\'e1\', \'e2\'])\n        print(pe._data)\n')
    __stickytape_write_module('inql/actions/executor.py', 'import platform\n\nif platform.system() != "Java":\n    print("Load this file inside jython, if you need the stand-alone tool run: inql")\n    exit(-1)\n\nfrom java.awt.event import ActionListener\nfrom javax.swing import JMenuItem\n\n\nclass ExecutorAction(ActionListener):\n    """\n    ExecutorAction class represent a context-free action class container.\n    During creation an action should be passed to defined the behaviour of this context free action.\n    """\n    def __init__(self, text, action=None):\n        self._action = action\n        self.menuitem = JMenuItem(text)\n        self.menuitem.setEnabled(True)\n        self.menuitem.addActionListener(self)\n\n    def actionPerformed(self, e):\n        """\n        Executes action if setup during creation.\n\n        :param e: unused\n        :return: None\n        """\n        if self._action:\n            self._action(e)\n\n    def ctx(self, host=None, payload=None, fname=None):\n        """\n        Do Nothing, stub implemented to be an action.\n        This is not needed since the action to be performed is context free and setup during object creation.\n\n        :param host: unused\n        :param payload: unused\n        :param fname: unused\n        :return: None\n        """\n        pass')
    __stickytape_write_module('inql/widgets/generator.py', 'from __future__ import print_function\nimport platform\n\n\nif platform.system() != "Java":\n    print("Load this file inside jython, if you need the stand-alone tool run: inql")\n    exit(-1)\n\n# JAVA GUI Import\nfrom java.awt import Color, BorderLayout\nfrom javax.swing import (JFrame, JPanel, JPopupMenu, JFileChooser)\nfrom java.lang import System\nfrom java.io import File\n\nimport os\nimport json\nimport string\nimport time\nimport sys\n\nfrom inql.actions.executor import ExecutorAction\nfrom inql.actions.browser import BrowserAction\nfrom inql.introspection import init\nfrom inql.constants import *\nfrom inql.widgets.omnibar import Omnibar\nfrom inql.widgets.fileview import FileView\nfrom inql.widgets.propertyeditor import PropertyEditor\nfrom inql.utils import inherits_popup_menu, AttrDict, run_async\n\n\nclass GeneratorPanel():\n    """\n    Compound class that represents the burp user interface tab.\n\n    It can run standalone with limited functionalities with: jython -m inql.widgets.tab\n    """\n    def __init__(self, actions=[], restore=None, proxy=None, http_mutator=None, texteditor_factory=None, requests=None, stub_responses=None):\n        self._requests = requests if requests is not None else {}\n        self._stub_responses = stub_responses if stub_responses is not None else {}\n        self._actions = actions\n        self._load_headers = []\n        self._run_config = [\n            [\'Proxy\', proxy],\n            [\'Authorization Key\', None],\n            [\'Load Placeholders\', True],\n            [\'Generate HTML DOC\', True],\n            [\'Generate Schema DOC\', False],\n            [\'Generate Stub Queries\', True],\n            [\'Accept Invalid SSL Certificate\', True],\n            [\'Generate Cycles Report\', False],\n            [\'Cycles Report Timeout\', 60],\n            [\'Generate TSV\', False]\n        ]\n        self._init_config = json.loads(json.dumps(self._run_config))\n        self._default_config = {}\n        for k, v in self._run_config:\n            self._default_config[k] = v\n        self._old_config_hash = None\n        self._actions.insert(0, BrowserAction())\n        self._actions.insert(0, ExecutorAction("Configure", lambda _: self._setup()))\n        self._actions.insert(0, ExecutorAction("Load", self._loadurl))\n        self._http_mutator = http_mutator\n\n        self.this = JPanel()\n        self.this.setLayout(BorderLayout())\n        self._omnibar = Omnibar(\n            hint=DEFAULT_LOAD_URL,\n            label="Load",\n            action=self._loadurl)\n        self.this.add(BorderLayout.PAGE_START, self._omnibar.this)\n        self._fileview = FileView(\n            dir=os.getcwd(),\n            filetree_label="Queries, Mutations and Subscriptions",\n            texteditor_factory=texteditor_factory)\n        self.this.add(BorderLayout.CENTER, self._fileview.this)\n        self._fileview.addTreeListener(self._tree_listener)\n        self._fileview.addPayloadListener(self._payload_listener)\n\n        self._popup = JPopupMenu()\n        self.this.setComponentPopupMenu(self._popup)\n        inherits_popup_menu(self.this)\n\n        for action in self._actions:\n            self._popup.add(action.menuitem)\n\n        self._state = {\'runs\': []}\n        try:\n            if restore:\n                cfg = json.loads(restore)\n                if \'runs\' in cfg:\n                    for target, key, proxy, headers, load_placeholer, generate_html, generate_schema, generate_queries, generate_cycles, cycles_timeout, generate_tsv, accept_invalid_certificate, flag in cfg[\'runs\']:\n                        self._run(target=target,\n                                  key=key,\n                                  proxy=proxy,\n                                  headers=headers,\n                                  load_placeholer=load_placeholer,\n                                  generate_html=generate_html,\n                                  generate_schema=generate_schema,\n                                  generate_queries=generate_queries,\n                                  generate_cycles=generate_cycles,\n                                  cycles_timeout=cycles_timeout,\n                                  generate_tsv=generate_tsv,\n                                  accept_invalid_certificate=accept_invalid_certificate,\n                                  flag=flag)\n                self._run_config = cfg[\'config\']\n        except Exception as ex:\n            print("Cannot Load old configuration: starting with a clean state: %s" % ex)\n            sys.stdout.flush()\n        self._state[\'config\'] = self._run_config\n\n    def _setup_headers(self):\n        """\n        Setup Headers callback\n        :return: None\n        """\n        PropertyEditor.get_instance(\n            text=\'Load Headers\',\n            columns=[\'Header\', \'Value\'],\n            data=self._load_headers,\n            empty=["X-New-Header", "X-New-Header-Value"])\n\n    def _setup(self):\n        """\n        Setup callback\n        :return: None\n        """\n        PropertyEditor.get_instance(\n            text="Configure InQL",\n            columns=[\'Property\', \'Value\'],\n            data=self._run_config,\n            actions=[\n                ExecutorAction("Setup Load Headers",\n                               lambda _: self._setup_headers()),\n                ExecutorAction("Reset",\n                               lambda _: self._reset())\n            ]\n        )\n\n    def _cfg(self, key):\n        """\n        :param key: the key of the configuration\n        :return: configuration value or default if unset\n        """\n        new_hash = hash(string.join([str(i) for _, i in self._run_config]))\n        if self._old_config_hash != new_hash:\n            self._config = {}\n            for k, v in self._run_config:\n                self._config[k] = v\n            self._old_config_hash = new_hash\n        try:\n            return self._config[key]\n        except KeyError:\n            try:\n                return self._default_config[key]\n            except KeyError:\n                return None\n\n    def state(self):\n        """\n        Tab State, used to regenerate the status after load.\n\n        :return: the current status in JSON format, this will be saved in BURP preferences for later reuse\n        """\n        return json.dumps(self._state)\n\n    def _reset(self):\n        """Reset configuration state"""\n        self._state[\'config\'] = json.loads(json.dumps(self._init_config))\n        self._run_config = self._state[\'config\']\n        self._state[\'runs\'] = {}\n\n\n    def _tree_listener(self, e):\n        """\n        Listen to Ftree change and act on that behalf.\n\n        :param e: get current path and set the context on every action.\n        :return: None\n        """\n        try:\n            host = [str(p) for p in e.getPath().getPath()][1]\n            self._host = host\n            fname = os.path.join(*[str(p) for p in e.getPath().getPath()][1:])\n            self._fname = fname\n            f = open(fname, "r")\n            payload = f.read()\n            for action in self._actions:\n                action.ctx(host=host, payload=payload, fname=fname)\n        except IOError:\n            pass\n\n    def _payload_listener(self, e):\n        """\n        Listen for Payload Change and change the context of every action accordingly.\n\n        :param e: event change.\n        :return: None\n        """\n\n        try:\n            doc = e.getDocument()\n            payload = doc.getText(0, doc.getLength())\n            for action in self._actions:\n                action.ctx(host=self._host, payload=payload, fname=self._fname)\n        except Exception:\n            pass\n\n    def _filepicker(self):\n        """\n        Run the filepicker and return if approved\n\n        :return: boolean, true if approved\n        """\n        fileChooser = JFileChooser()\n        fileChooser.setCurrentDirectory(File(System.getProperty("user.home")))\n        result = fileChooser.showOpenDialog(self.this)\n        isApproveOption = result == JFileChooser.APPROVE_OPTION\n        if isApproveOption:\n            selectedFile = fileChooser.getSelectedFile()\n            self._omnibar.setText(selectedFile.getAbsolutePath())\n        return isApproveOption\n\n    def _loadurl(self, evt):\n        """\n        load url if present.\n\n        :param evt: load url or reload itself with the same evt.\n        :return: None\n        """\n        target = self._omnibar.getText().strip()\n        if target == DEFAULT_LOAD_URL:\n            if self._filepicker():\n                self._loadurl(evt)\n        elif target == \'about:config\':\n            self._setup()\n            self._omnibar.reset()\n        elif target == \'about:headers\':\n            self._setup_headers()\n            self._omnibar.reset()\n        elif target.startswith(\'http://\') or target.startswith(\'https://\'):\n            print("Quering GraphQL schema from: %s" % target)\n            self._run(target=target,\n                      key=self._cfg(\'Authorization Key\'),\n                      proxy=self._cfg(\'Proxy\'),\n                      headers=self._load_headers,\n                      load_placeholer=self._cfg(\'Load Placeholders\'),\n                      generate_html=self._cfg(\'Generate HTML DOC\'),\n                      generate_schema=self._cfg(\'Generate Schema DOC\'),\n                      generate_queries=self._cfg(\'Generate Stub Queries\'),\n                      generate_cycles=self._cfg(\'Generate Cycles Report\'),\n                      cycles_timeout=self._cfg(\'Cycles Report Timeout\'),\n                      generate_tsv=self._cfg(\'Generate TSV\'),\n                      accept_invalid_certificate=self._cfg(\'Accept Invalid SSL Certificate\'),\n                      flag="URL")\n        elif not os.path.isfile(target):\n            if self._filepicker():\n                self._loadurl(evt)\n        else:\n            print("Loading JSON schema from: %s" % target)\n            self._run(target=target,\n                      key=self._cfg(\'Authorization Key\'),\n                      proxy=self._cfg(\'Proxy\'),\n                      headers=self._load_headers,\n                      load_placeholer=self._cfg(\'Load Placeholders\'),\n                      generate_html=self._cfg(\'Generate HTML DOC\'),\n                      generate_schema=self._cfg(\'Generate Schema DOC\'),\n                      generate_queries=self._cfg(\'Generate Stub Queries\'),\n                      generate_cycles=self._cfg(\'Generate Cycles Report\'),\n                      cycles_timeout=self._cfg(\'Cycles Report Timeout\'),\n                      generate_tsv=self._cfg(\'Generate TSV\'),\n                      accept_invalid_certificate=self._cfg(\'Accept Invalid SSL Certificate\'),\n                      flag="JSON")\n\n\n    def _run(self, target, key, proxy, headers, load_placeholer, generate_html, generate_schema, generate_queries,\n             generate_cycles, cycles_timeout, generate_tsv, accept_invalid_certificate, flag):\n        """\n        Run the actual analysis, this method is a wrapper for the non-UI version of the tool and basically calls the\n        main/init method by itself.\n\n        :param target: target URL\n        :param load_placeholer: load placeholder option\n        :param generate_html: generate html option\n        :param generate_schema: generate schema option\n        :param generate_queries: generate queries option\n        :param flag: "JSON" file or normal target otherwise\n        :return: None\n        """\n        self._omnibar.reset()\n        args = {"key": key, "proxy": proxy, \'headers\': headers, "detect": load_placeholer,\n                "generate_html": generate_html,\n                "generate_schema": generate_schema,\n                "generate_queries": generate_queries,\n                "generate_cycles": generate_cycles,\n                "cycles_timeout": cycles_timeout,\n                "cycles_streaming": False, # there is no UI to show streaming cycles.\n                "generate_tsv": generate_tsv,\n                "target": target if flag != "JSON" else None,\n                "schema_json_file": target if flag == "JSON" else None,\n                "insecure_certificate": accept_invalid_certificate,\n                "requests": self._requests,\n                "stub_responses": self._stub_responses}\n\n        # call init method from Introspection tool\n        if flag == \'JSON\':\n            with open(target, \'r\') as f:\n                host = os.path.splitext(os.path.basename(target))[0]\n                self._http_mutator.set_stub_response(host, f.read())\n\n        def async_run():\n            init(AttrDict(args.copy()))\n            self._state[\'runs\'].append((\n                target, key, proxy, headers, load_placeholer, generate_html, generate_schema, generate_queries,\n                generate_cycles, cycles_timeout, generate_tsv, accept_invalid_certificate, flag))\n            self._fileview.refresh()\n\n        run_async(async_run)\n        return\n\n    def app(self, label="InQL Scanner"):\n        frame = JFrame(label)\n        frame.setForeground(Color.black)\n        frame.setBackground(Color.lightGray)\n        cp = frame.getContentPane()\n        cp.add(self.this)\n        frame.pack()\n        frame.setVisible(True)\n        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE)\n        while frame.isVisible():\n            time.sleep(1)\n\nif __name__ == "__main__":\n    import tempfile\n    tmpdir = tempfile.mkdtemp()\n    from java.awt.event import ActionListener\n    from javax.swing import JMenuItem\n\n    class TestAction(ActionListener):\n        def __init__(self, text):\n            self.requests = {}\n            self.menuitem = JMenuItem(text)\n            self.menuitem.addActionListener(self)\n            self.enabled = True\n            self.menuitem.setEnabled(self.enabled)\n\n        def actionPerformed(self, e):\n            self.enabled = not self.enabled\n            self.menuitem.setEnabled(self.enabled)\n\n        def ctx(self, host=None, payload=None, fname=None):\n            pass\n    print("Changing dir to %s" % tmpdir)\n    os.chdir(tmpdir)\n    GeneratorPanel(actions=[TestAction("test it")]).app()')
    __stickytape_write_module('inql/introspection.py', 'from __future__ import print_function\n\ntry:\n    import urllib.request as urllib_request # for Python 3\nexcept ImportError:\n    import urllib2 as urllib_request # for Python 2 and Jython\ntry:\n    from urllib.parse import urlparse # for Python 3\nexcept ImportError:\n    from urlparse import urlparse # for Python 2 and Jython\n\nimport argparse\nimport time\nimport os\nimport json\nimport sys\nimport platform\nfrom datetime import date\n\n\nfrom .utils import string_join, mkdir_p, raw_request, urlopen\nfrom .generators import html, schema, cycles, query, tsv\n\ntry:\n    # Use UTF8 On Python2 and Jython\n    reload(sys)\n    sys.setdefaultencoding(\'UTF8\')\nexcept NameError:\n    pass # Nothing Needed in Python3\n\n\ndef wrap_exit(method, exceptions = (OSError, IOError)):\n    """\n    Wrap exit method to write the error and reset colors to the output before exiting.\n    :param method: exit method\n    :param exceptions:\n    :return:\n    """\n    def fn(*args, **kwargs):\n        try:\n            print(reset)\n            return method(*args, **kwargs)\n        except exceptions:\n            sys.exit(\'Can\\\'t open \\\'{0}\\\'. Error #{1[0]}: {1[1]}\'.format(args[0], sys.exc_info()[1].args))\n\n    return fn\nexit = wrap_exit(exit)\n\n# colors for terminal messages\nred = ""\ngreen = ""\nwhite = ""\nyellow = ""\nreset = ""\n\ndef posix_colors():\n    """\n    Setup global POSIX shell colors.\n    :return: None\n    """\n    global red, green, white, yellow, reset\n    red = "\\033[1;31;10m[!] "\n    green = "\\033[1;32;10m[+] "\n    white = "\\033[1;37;10m"\n    yellow = "\\033[1;33;10m[!] "\n    reset = "\\033[0;0m"\n\ndef supports_color():\n    """\n    Returns True if the running system\'s terminal supports color, and False\n    otherwise.\n    """\n    plat = sys.platform\n    supported_platform = plat != \'Pocket PC\' and (plat != \'win32\' or\n                                                  \'ANSICON\' in os.environ)\n    # isatty is not always implemented, #6223.\n    is_a_tty = hasattr(sys.stdout, \'isatty\') and sys.stdout.isatty()\n    return supported_platform and is_a_tty\n\n\nif supports_color():\n    posix_colors()\n\n\ndef query_result(target, key, headers=None, verify_certificate=True, requests=None, stub_responses=None):\n    """\n    Execute the introspection query against the GraphQL endpoint\n\n    :param target:\n        Expects a valid URL ex. https://example.com/graphql\n        Raise an exception if HTTP/HTTPS schema is missing\n\n    :param key:\n        Optional parameter to be used as authentication header\n        "Basic dXNlcjp0ZXN0"\n        "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9"\n\n    :return:\n        Returns a dictionary objects to be parsed\n    """\n    headers = headers.copy() if headers else {}\n    requests = requests if requests is not None else {}\n    stub_responses = stub_responses if stub_responses is not None else {}\n    # Introspection Query\n    # -----------------------\n    introspection_query =  "query IntrospectionQuery{__schema{queryType{name}mutationType{name}subscriptionType{name}types{...FullType}directives{name description locations args{...InputValue}}}}fragment FullType on __Type{kind name description fields(includeDeprecated:true){name description args{...InputValue}type{...TypeRef}isDeprecated deprecationReason}inputFields{...InputValue}interfaces{...TypeRef}enumValues(includeDeprecated:true){name description isDeprecated deprecationReason}possibleTypes{...TypeRef}}fragment InputValue on __InputValue{name description type{...TypeRef}defaultValue}fragment TypeRef on __Type{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name}}}}}}}}"\n    old_introspection_query =  "query IntrospectionQuery{__schema{queryType{name}mutationType{name}subscriptionType{name}types{...FullType}directives{name description args{...InputValue}onOperation onFragment onField}}}fragment FullType on __Type{kind name description fields(includeDeprecated:true){name description args{...InputValue}type{...TypeRef}isDeprecated deprecationReason}inputFields{...InputValue}interfaces{...TypeRef}enumValues(includeDeprecated:true){name description isDeprecated deprecationReason}possibleTypes{...TypeRef}}fragment InputValue on __InputValue{name description type{...TypeRef}defaultValue}fragment TypeRef on __Type{kind name ofType{kind name ofType{kind name ofType{kind name}}}}"\n    # -----------------------\n    if \'User-Agent\' not in headers:\n        headers[\'User-Agent\'] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0"\n\n    if key:\n        headers[\'Authorization\'] = key\n\n    try:\n        # Issue the Introspection request against the GraphQL endpoint\n        request = urllib_request.Request(target, json.dumps({"query": introspection_query}, sort_keys=True).encode(\'UTF-8\'), headers=headers)\n        request.add_header(\'Content-Type\', \'application/json\')\n\n        url = urlparse(target)\n        reqbody = raw_request(request)\n        if url.netloc not in requests:\n            requests[url.netloc] = {}\n        requests[url.netloc][\'POST\'] = (None, reqbody)\n        requests[url.netloc][\'url\'] = target\n\n        contents = urlopen(request, verify=verify_certificate).read()\n\n        stub_responses[url.netloc] = contents\n\n        return contents\n\n    except Exception as e:\n        print(string_join(red, str(e), reset))\n\ndef main():\n    """\n    Query a GraphQL endpoint with introspection in order to retrieve the documentation of all the Queries, Mutations & Subscriptions.\n    It will also generate Queries, Mutations & Subscriptions templates (with optional placeholders) for all the known types.\n\n    :return:\n        none\n    """\n    # Args parser definition\n    # -----------------------\n    parser = argparse.ArgumentParser(prog="inql", description="InQL Scanner")\n    if platform.system() == "Java":\n        parser.add_argument("--nogui", default=False, dest="nogui",\n                            action="store_true", help="Start InQL Without Standalone GUI [Jython-only]")\n    parser.add_argument("-t", default=None, dest="target",\n                        help="Remote GraphQL Endpoint (https://<Target_IP>/graphql)")\n    parser.add_argument("-f", dest="schema_json_file", default=None, help="Schema file in JSON format")\n    parser.add_argument("-k", dest="key", help="API Authentication Key")\n    parser.add_argument(\'-p\', dest="proxy", default=None,\n                        help=\'IP of a web proxy to go through (http://127.0.0.1:8080)\')\n    parser.add_argument(\'--header\', dest="headers", nargs=2, action=\'append\')\n    parser.add_argument("-d", dest="detect", action=\'store_true\', default=False,\n                        help="Replace known GraphQL arguments types with placeholder values (useful for Burp Suite)")\n    parser.add_argument("--no-generate-html", dest="generate_html", action=\'store_false\', default=True,\n                        help="Generate HTML Documentation")\n    parser.add_argument("--no-generate-schema", dest="generate_schema", action=\'store_false\', default=True,\n                        help="Generate JSON Schema Documentation")\n    parser.add_argument("--no-generate-queries", dest="generate_queries", action=\'store_false\', default=True,\n                        help="Generate Queries")\n    parser.add_argument("--generate-cycles", dest="generate_cycles", action=\'store_true\', default=False,\n                        help="Generate Cycles Report")\n    parser.add_argument("--cycles-timeout", dest="cycles_timeout", default=60, type=int,\n                        help="Cycles Report Timeout (in seconds)")\n    parser.add_argument("--cycles-streaming", dest="cycles_streaming", action=\'store_true\', default=False,\n                        help="Some graph are too complex to generate cycles in reasonable time, stream to stdout")\n    parser.add_argument("--generate-tsv", dest="generate_tsv", action=\'store_true\', default=False,\n                        help="Generate TSV representation of query templates. It may be useful to quickly search for vulnerable I/O.")\n    parser.add_argument("--insecure", dest="insecure_certificate", action="store_true",\n                        help="Accept any SSL/TLS certificate")\n    parser.add_argument("-o", dest="output_directory", default=os.getcwd(),\n                        help="Output Directory")\n    args = parser.parse_args()\n    # -----------------------\n    args.requests = {}\n    args.stub_responses = {}\n\n    mkdir_p(args.output_directory)\n    os.chdir(args.output_directory)\n\n    if platform.system() == "Java" and args.nogui is not True:\n        from inql.widgets.generator import GeneratorPanel\n        from inql.actions.sendto import SimpleMenuItem, SendToAction, HTTPMutator\n        from inql.actions.setcustomheader import CustomHeaderSetterAction\n        overrideheaders = {}\n        graphiql_omnimenu = SimpleMenuItem(text="Send to GraphiQL")\n        http_mutator = HTTPMutator(\n            requests=args.requests,\n            stub_responses=args.stub_responses,\n            overrideheaders=overrideheaders)\n        graphiql_sender = SendToAction(omnimenu=graphiql_omnimenu,\n                                       send_to=http_mutator.send_to_graphiql, has_host=http_mutator.has_host)\n        custom_header_setter = CustomHeaderSetterAction(overrideheaders=overrideheaders, text="Set Custom Header")\n        cfg = [\n            [\'Proxy\', args.proxy],\n            [\'Authorization Key\', args.key],\n            [\'Load Placeholders\', args.detect],\n            [\'Generate HTML DOC\', args.generate_html],\n            [\'Generate Schema DOC\', args.generate_schema],\n            [\'Generate Stub Queries\', args.generate_queries],\n            [\'Accept Invalid SSL Certificate\', args.insecure_certificate],\n            [\'Generate Cycles Report\', args.generate_cycles],\n            [\'Cycles Report Timeout\', args.cycles_timeout],\n            [\'Generate TSV\', args.generate_tsv]\n        ]\n        return GeneratorPanel(\n            actions=[custom_header_setter, graphiql_sender],\n            restore=json.dumps({\'config\': cfg}),\n            http_mutator=None,\n            requests=args.requests,\n            stub_responses=args.stub_responses\n        ).app()\n    else:\n        return init(args, lambda: parser.print_help())\n\n\ndef init(args, print_help=None):\n    """\n    Main Introspection method.\n\n    :param args: arg parser alike arguments\n    :param print_help: print help lambda\n    :return: None\n    """\n    # At least one between -t or -f (target) parameters must be set\n    if args.target is None and args.schema_json_file is None:\n        print(string_join(red, "Remote GraphQL Endpoint OR a Schema file in JSON format must be specified!", reset))\n        if print_help:\n            print_help()\n            exit(1)\n\n    # Only one of them -t OR -f :)\n    if args.target is not None and args.schema_json_file is not None:\n        print(string_join(red, "Only a Remote GraphQL Endpoint OR a Schema file in JSON format must be specified, not both!", reset))\n        if print_help:\n            print_help()\n            exit(1)\n\n    # Takes care of any configured proxy (-p param)\n    if args.proxy is not None:\n        print(string_join(yellow, "Proxy ENABLED: ", args.proxy, reset))\n        os.environ[\'http_proxy\'] = args.proxy\n        os.environ[\'https_proxy\'] = args.proxy\n\n    # Generate Headers object\n    headers = {}\n    if args.headers:\n        for k, v in args.headers:\n            headers[k] = v\n\n    if args.target is not None or args.schema_json_file is not None:\n        if args.target is not None:\n            # Acquire GraphQL endpoint URL as a target\n            host = urlparse(args.target).netloc\n        else:\n            # Acquire a local JSON file as a target\n            print(string_join(yellow, "Parsing local schema file", reset))\n            host = os.path.splitext(os.path.basename(args.schema_json_file))[0]\n        if args.detect:\n            print(string_join(yellow, "Detect arguments is ENABLED, known types will be replaced with placeholder values", reset))\n        # Used to generate \'unique\' file names for multiple documentation\n        timestamp = str(int(time.time()))  # Can be printed with: str(int(timestamp))\n        today = str(date.today())\n        # -----------------------\n        # Custom Objects are required for fields names in the documentation and templates generation\n        # old -c parameter, enabled by default\n        custom = True\n        # Generate the documentation for the target\n        if args.target is not None:\n            # Parse response from the GraphQL endpoint\n            argument = query_result(target=args.target,\n                                    key=args.key,\n                                    headers=headers,\n                                    verify_certificate=not args.insecure_certificate,\n                                    requests=args.requests,\n                                    stub_responses=args.stub_responses)\n            # returns a dict\n            argument = json.loads(argument)\n        else:\n            # Parse the local JSON file\n            with open(args.schema_json_file, "r") as s:\n                result_raw = s.read()\n                argument = json.loads(result_raw)\n\n        if args.generate_schema:\n            schema.generate(argument,\n                            fpath=os.path.join(host, "schema-%s-%s.json" % (today, timestamp)),\n                            green_print=lambda s: print(string_join(green, s, reset)))\n        if args.generate_html:\n            html.generate(argument,\n                          fpath=os.path.join(host, "doc-%s-%s.html" % (today, timestamp)),\n                          custom=custom,\n                          target=args.target,\n                          green_print=lambda s: print(string_join(green, s, reset)))\n        if args.generate_queries:\n            query.generate(argument,\n                           qpath=os.path.join(host, "%s", today, timestamp, "%s"),\n                           detect=args.detect,\n                           green_print=lambda s: print(string_join(green, s, reset)))\n\n        if args.generate_cycles:\n            cycles.generate(argument,\n                            fpath=os.path.join(host, "cycles-%s-%s.txt" % (today, timestamp)),\n                            timeout=args.cycles_timeout,\n                            streaming=args.cycles_streaming,\n                            green_print=lambda s: print(string_join(green, s, reset)))\n\n        if args.generate_tsv:\n            tsv.generate(argument,\n                         fpath=os.path.join(host, "endpoint_%s.tsv"),\n                         green_print=lambda s: print(string_join(green, s, reset)))\n\n    else:\n        # Likely missing a required arguments\n        print("Missing Arguments")\n        if print_help:\n            print(white)\n            print_help()\n            print(reset)\n            exit(1)\n\n\nif __name__ == "__main__":\n    try:\n        main()\n    except KeyboardInterrupt:\n        # Catch CTRL+C, it will abruptly kill the script\n        print(string_join(red, "Exiting...", reset))\n        exit(-1)\n')
    __stickytape_write_module('inql/generators/__init__.py', '')
    __stickytape_write_module('inql/generators/html.py', 'from __future__ import print_function\nfrom inql.utils import open\n\n\n# CSS style used for the documentation\nstl = """\n<style>\nbody {\n  font-family: Roboto;\n  background-color: #f9f9f9;\n}\n\nli.query {\n  color: #368cbf;\n}\n\nli.mutation {\n  color: #30a;\n}\n\nli.subscription {\n  color: #397D13;\n}\n\nli.argument {\n  color: #edae49;\n}\n\nli.type {\n  color: #7ebc59;\n}\n\nli.deprecated {\n  color: red;\n  ext-decoration: underline wavy red;\n}\n\nli.field {\n\n}\n\nli.description {\n  color: grey;\n}\nspan.query {\n  color: #368cbf;\n}\n\nspan.mutation {\n  color: #30a;\n}\n\nspan.subscription {\n  color: #397D13;\n}\n\nspan.argument {\n  color: #edae49;\n}\n\nspan.type {\n  color: #7ebc59;\n}\n\nspan.deprecated {\n  color: red;\n  ext-decoration: underline wavy red;\n}\n\nspan.field {\n\n}\n\nspan.description {\n  color: grey;\n}\n\ndiv.box {\n  background-color: white;\n  width: 300px;\n  border: 5px solid grey;\n  padding: 10px;\n  margin: 10px;\n}\n</style>\n"""\n\n\ndef generate(argument, fpath, custom=False, target="empty", green_print=lambda s: print(s)):\n    """\n    Generate HTML Documentation\n\n    :param argument: introspection query result\n    :param fpath: output result\n    :param custom: enable or disable custom types, disabled by default\n    :param target: who is the owner of that graphql endpoint\n    :return: None\n    """\n    green_print("Writing HTML Documentation")\n    with open(fpath, \'w\') as output_file:\n        result = argument.copy()\n        # Write HTML header for the documentation\n        # --------------------\n        output_file.write("<html><head><title>GraphQL Schema</title>")\n        # write CSS\n        output_file.write(stl)\n        # write target URL\n        output_file.write("</head><body><h2>GraphQL Schema</h2><h3><a href=\'{0}\'>{0}</a></h3>".format(target))\n        # write legend box\n        output_file.write(\n            "<div class=\'box\'><h4>Legend</h4><ul><li class=\'query\'>Queries</li><li class=\'mutation\'>Mutations</li><"\n            "li class=\'subscription\'>Subscriptions</li><li class=\'argument\'>Arguments</li>"\n            "<li class=\'type\'>Types: String, Float, not_null!, [list]</li><li class=\'deprecated\'>Deprecated</li>"\n            "<li class=\'field\'>Fields</li></ul></div>")\n        # --------------------\n        output_file.write("<p>Available Operations Types:</p>")\n        try:\n            # Print available operation types, usually: Query, Mutations & Subscriptions\n            # This part also holds custom names (schema[Type][\'name\'] != \'RootQuery\', \'RootMutation\', \'Subscriptions\')\n            # --------------------\n            if result[\'data\'][\'__schema\'][\'mutationType\'] is not None:\n                output_file.write("<ul><li class=\'mutation\'>{0}</li>".format(\n                    result[\'data\'][\'__schema\'][\'mutationType\'][\'name\']))\n                Mutation = result[\'data\'][\'__schema\'][\'mutationType\'][\'name\']\n            else:\n                # Needed since not all GraphQL endpoints use/have all the three types (Query, Mutations & Subscriptions)\n                Mutation = None\n            if result[\'data\'][\'__schema\'][\'queryType\'] is not None:\n                output_file.write("<li class=\'query\'>{0}</li>".format(\n                    result[\'data\'][\'__schema\'][\'queryType\'][\'name\']))\n                Query = result[\'data\'][\'__schema\'][\'queryType\'][\'name\']\n            else:\n                Query = None\n            if result[\'data\'][\'__schema\'][\'subscriptionType\'] is not None:\n                output_file.write(\n                    "<li class=\'subscription\'>{0}</li></ul>".format(\n                        result[\'data\'][\'__schema\'][\'subscriptionType\'][\'name\']))\n                Subscription = result[\'data\'][\'__schema\'][\'subscriptionType\'][\'name\']\n            else:\n                Subscription = None\n            # --------------------\n            i = 0\n            ##########################################################################################\n            # Parsing JSON response/file structure as follows\n            # data\n            #   __schema\n            #       directives\n            #       mutationType\n            #       queryType\n            #       subscriptionType\n            #       types (kind, name, description)\n            #              name (RootQuery, RootMutation, Subscriptions, [custom] OBJECT)\n            #              fields\n            #                     name (query names)\n            #                     args\n            #                            name (args names)\n            #                            type\n            #                                   name (args types)\n            ##########################################################################################\n            # Start looping trough types\n            if result[\'data\'][\'__schema\'][\'types\'] is not None:\n                rt = result[\'data\'][\'__schema\'][\'types\']\n                # holds the number of custom objects\n                xxx = 0\n                for types in rt:\n                    j = 0\n                    # Data -> Schema -> Types (kind, name, description)\n                    # filtering out primitive types\n                    # TODO: exclude interfaces & union types\n                    primitives = [\'Int\', \'Float\', \'String\', \'Boolean\', \'ID\', \'__TypeKind\', \'__Type\', \'__Schema\',\n                                  \'__Field\', \'__InputValue\', \'__EnumValue\', \'__Directive\', \'__DirectiveLocation\']\n                    advanced_kind = [\'INPUT_OBJECT\']\n                    # This super if is BOOLEAN able to switch between ENABLED custom types parameter (-c)\n                    # It will selectively routine trough values needed to print\n                    if ((custom is False and ((rt[i][\'kind\'] is not None and rt[i][\'name\'] is not None) and (\n                            rt[i][\'name\'] not in primitives) and (rt[i][\'kind\'] not in advanced_kind) and (\n                                                      (rt[i][\'kind\'] == "OBJECT") and (\n                                                      (rt[i][\'name\'] == Query) or (rt[i][\'name\'] == Mutation) or (\n                                                      rt[i][\'name\'] == Subscription))))) or (\n                            custom is not False and ((rt[i][\'kind\'] is not None and rt[i][\'name\'] is not None) and (\n                            rt[i][\'name\'] not in primitives) and (rt[i][\'kind\'] not in advanced_kind)))):\n                        output_file.write("<li>{0}</li>".format(rt[i][\'kind\']))\n                        # Print our types RootQuery, RootMutation, Subscriptions\n                        # --------------------\n                        if rt[i][\'name\'] == Mutation:\n                            output_file.write("<li class=\'mutation\'>{0}</li>".format(rt[i][\'name\']))\n                        elif rt[i][\'name\'] == Query:\n                            output_file.write("<li class=\'query\'>{0}</li>".format(rt[i][\'name\']))\n                        elif rt[i][\'name\'] == Subscription:\n                            output_file.write("<li class=\'subscription\'>{0}</li>".format(rt[i][\'name\']))\n                        # Handles custom objects (FIELDS)\n                        elif rt[i][\'kind\'] == "OBJECT" and rt[i][\'name\'] is not None:\n                            output_file.write("<span class=\'type\'>{0}</span><br>".format(rt[i][\'name\']))\n                            xxx += 1\n                        if rt[i][\'description\'] is not None:\n                            output_file.write(\n                                "<span class=\'description\'>{0}</span><br>".format(rt[i][\'description\']))\n                        # --------------------\n                    k = 0\n                    # Retrieving general docs regarding primitives (filtered out from documentation, not needed)\n                    # Data -> Schema -> Types -> enumValues (name, description, isDeprecated, deprecationReason)\n                    # My super BOOLEAN IF, used to switch between ENABLED custom types parameter (-c)\n                    if ((custom is False and (\n                            rt[i][\'enumValues\'] is not None and (rt[i][\'name\'] not in primitives) and (\n                            rt[i][\'kind\'] not in advanced_kind) and (\n                                    (rt[i][\'kind\'] == "OBJECT") and (\n                                    (rt[i][\'name\'] == Query) or (rt[i][\'name\'] == Mutation) or (\n                                    rt[i][\'name\'] == Subscription))))) or (\n                            custom is not False and ((rt[i][\'enumValues\'] is not None) and (\n                            rt[i][\'name\'] not in primitives) and (rt[i][\'kind\'] not in advanced_kind)))):\n                        for enumValues in rt[i][\'enumValues\']:\n                            # Name\n                            if rt[i][\'enumValues\'][k][\'name\'] is not None:\n                                output_file.write("<span>{0}</span><br>".format(rt[i][\'enumValues\'][k][\'name\']))\n                            # Description\n                            if rt[i][\'enumValues\'][k][\'description\'] is not None:\n                                output_file.write("<span class=\'description\'>{0}</span><br>".format(\n                                    rt[i][\'enumValues\'][k][\'description\']))\n                            # Is Deprecated?\n                            if rt[i][\'enumValues\'][k][\'isDeprecated\'] is not False and rt[i][\'enumValues\'][k][\n                                \'isDeprecated\'] is not None:\n                                output_file.write("<span class=\'deprecated\'>Is Deprecated</span><br>")\n                            # Deprecation Reason\n                            if rt[i][\'enumValues\'][k][\'deprecationReason\'] is not None:\n                                output_file.write("<span>Reason: {0}</span><br>".format(\n                                    rt[i][\'enumValues\'][k][\'deprecationReason\']))\n                            k = k + 1\n                    # Retrieving queries, mutations and subscriptions information\n                    # Data -> Schema -> Types -> Fields (name, isDeprecated, deprecationReason, description)\n                    # My super BOOLEAN IF, used to switch between ENABLED custom types parameter (-c)\n                    if ((custom is False and ((\n                                                      rt[i][\'fields\'] is not None) and (\n                                                      rt[i][\'name\'] not in primitives) and (\n                                                      rt[i][\'kind\'] not in advanced_kind) and (\n                                                      (rt[i][\'kind\'] == "OBJECT") and (\n                                                      (rt[i][\'name\'] == Query) or (rt[i][\'name\'] == Mutation) or (\n                                                      rt[i][\'name\'] == Subscription))))) or (\n                            custom is not False and ((\n                                                             rt[i][\'fields\'] is not None) and (\n                                                             rt[i][\'name\'] not in primitives) and (\n                                                             rt[i][\'kind\'] not in advanced_kind)))):\n                        # Printing out queries, mutations, subscriptions and custom object names\n                        # --------------------\n                        # number of fields per obj\n                        for fields in result[\'data\'][\'__schema\'][\'types\'][i][\'fields\']:\n                            if rt[i][\'fields\'][j][\'name\'] is not None:\n                                # Query\n                                if rt[i][\'name\'] == Query:\n                                    output_file.write(\n                                        "<li class=\'query\'>{0}</li>".format(rt[i][\'fields\'][j][\'name\']))\n                                # Mutation\n                                elif rt[i][\'name\'] == Mutation:\n                                    output_file.write(\n                                        "<li class=\'mutation\'>{0}</li>".format(rt[i][\'fields\'][j][\'name\']))\n                                # Subscription\n                                elif rt[i][\'name\'] == Subscription:\n                                    output_file.write(\n                                        "<li class=\'subscription\'>{0}</li>".format(rt[i][\'fields\'][j][\'name\']))\n                                # It handle custom objects\n                                elif rt[i][\'kind\'] == "OBJECT":\n                                    output_file.write(\n                                        "<span class=\'field\'>{0}</span>&nbsp;&nbsp;".format(\n                                            rt[i][\'fields\'][j][\'name\']))\n                                # Seems that i do not need the following two lines\n                                # else:\n                                #    output_file.write("<li>{0}</li>".format(rt[i][\'fields\'][j][\'name\']))\n                            # --------------------\n                            # Printing info regarding the queries, mutations and subscriptions above\n                            # --------------------\n                            # Deprecated\n                            if rt[i][\'fields\'][j][\'isDeprecated\'] is not False and rt[i][\'fields\'][j][\n                                \'isDeprecated\'] is not None:\n                                output_file.write("<span class=\'deprecated\'>Is Deprecated</span><br>")\n                            # Deprecated Reason\n                            if rt[i][\'fields\'][j][\'deprecationReason\'] is not None:\n                                output_file.write(\n                                    "<span>Reason: {0}</span><br>".format(rt[i][\'fields\'][j][\'deprecationReason\']))\n                            # Description\n                            if rt[i][\'fields\'][j][\'description\'] is not None and rt[i][\'fields\'][j][\n                                \'description\'] != \'\':\n                                output_file.write(\n                                    "<span class=\'description\'>{0}</span><br>".format(\n                                        rt[i][\'fields\'][j][\'description\']))\n                            # Name (fields type)\n                            if rt[i][\'fields\'][j][\'type\'] is not None:\n                                if rt[i][\'fields\'][j][\'type\'][\'name\'] is not None:\n                                    output_file.write("<span class=\'type\'>{0}</span><br>".format(\n                                        rt[i][\'fields\'][j][\'type\'][\'name\']))\n                            # oFType\n                            if rt[i][\'fields\'][j][\'type\'][\'ofType\'] is not None and \\\n                                    rt[i][\'fields\'][j][\'type\'][\'ofType\'][\'name\'] is not None:\n                                # LIST\n                                if rt[i][\'fields\'][j][\'type\'][\'kind\'] is not None and rt[i][\'fields\'][j][\'type\'][\n                                    \'kind\'] == "LIST":\n                                    output_file.write("<span class=\'type\'>[{0}]</span><br>".format(\n                                        rt[i][\'fields\'][j][\'type\'][\'ofType\'][\'name\']))\n                                # NOT NULL\n                                elif rt[i][\'fields\'][j][\'type\'][\'kind\'] is not None and rt[i][\'fields\'][j][\'type\'][\n                                    \'kind\'] == "NON_NULL":\n                                    output_file.write("<span class=\'type\'>!{0}</span><br>".format(\n                                        rt[i][\'fields\'][j][\'type\'][\'ofType\'][\'name\']))\n                                # CUSTOM TYPE\n                                else:\n                                    output_file.write("<span class=\'type\'>{0}</span><br>".format(\n                                        rt[i][\'fields\'][j][\'type\'][\'ofType\'][\'name\']))\n                            # --------------------\n                            x = 0\n                            # Prepare a list of ARGS names for queries, mutations and subscriptions\n                            # --------------------\n                            # My super BOOLEAN IF, used to switch between ENABLED custom types parameter (-c)\n                            if ((custom is False and ((rt[i][\'fields\'][j][\'args\'] is not None) and (\n                                    rt[i][\'name\'] not in primitives) and (\n                                                              rt[i][\'kind\'] not in advanced_kind) and (\n                                                              (rt[i][\'kind\'] == "OBJECT") and (\n                                                              (rt[i][\'name\'] == Query) or (\n                                                              rt[i][\'name\'] == Mutation) or (\n                                                                      rt[i][\'name\'] == Subscription))))) or (\n                                    custom is not False and ((rt[i][\'fields\'][j][\'args\'] is not None) and (\n                                    rt[i][\'name\'] not in primitives) and (rt[i][\'kind\'] not in advanced_kind)))):\n                                # Printing out queries, mutations and subscriptions ARGS name\n                                # Data -> Schema -> Types -> Fields -> Args (defaultValue, name, description)\n                                # --------------------\n                                for args in rt[i][\'fields\'][j][\'args\']:\n                                    # Default value if present\n                                    if rt[i][\'fields\'][j][\'args\'][x][\'defaultValue\'] is not None:\n                                        output_file.write(\n                                            "<span>{0}</span><br>".format(\n                                                rt[i][\'fields\'][j][\'args\'][x][\'defaultValue\']))\n                                    # ARGS name\n                                    if rt[i][\'fields\'][j][\'args\'][x][\'name\'] is not None:\n                                        output_file.write("<span class=\'argument\'>{0}</span>&nbsp;&nbsp;".format(\n                                            rt[i][\'fields\'][j][\'args\'][x][\'name\']))\n                                    # ARGS description\n                                    if rt[i][\'fields\'][j][\'args\'][x][\'description\'] is not None and \\\n                                            rt[i][\'fields\'][j][\'args\'][x][\'description\'] != \'\':\n                                        output_file.write("<span class=\'description\'>{0}</span><br>".format(\n                                            rt[i][\'fields\'][j][\'args\'][x][\'description\']))\n                                    # --------------------\n                                    # Printing out ARGS types\n                                    # Data -> Schema -> Types -> Fields -> Args -> Type (name, ofType, kind)\n                                    # TODO half a bug: there are custom objects that have multiple types as the following example\n                                    # in this case ![LIST], at the moment this specific case is handled casting the returning value of\n                                    # rt[i][\'fields\'][j][\'args\'][x][\'type\'][\'ofType\'][\'name\'] to STRING\n                                    # in order to prevent errors (None type concatenated to a string)\n                                    # we are missing the custom object but at least the script does not falls apart\n                                    """\n                                         "description":null,\n                                         "isDeprecated":false,\n                                         "args":[  ],\n                                         "deprecationReason":null,\n                                         "type":{  \n                                            "kind":"NON_NULL",\n                                            "name":null,\n                                            "ofType":{  \n                                               "kind":"LIST",\n                                               "name":null,\n                                               "ofType":{  \n                                                  "kind":"NON_NULL",\n                                                  "name":null,\n                                                  "ofType":{  \n                                                     "kind":"SCALAR",\n                                                     "name":"String",\n                                                     "ofType":null\n                                                  }\n                                               }\n                                            }\n                                         },\n                                         "name":"roles"\n                                    """\n                                    # --------------------\n                                    if rt[i][\'fields\'][j][\'args\'][x][\'type\'] is not None and (\n                                            rt[i][\'name\'] not in primitives) and (\n                                            rt[i][\'kind\'] not in advanced_kind):\n                                        # LIST\n                                        if rt[i][\'fields\'][j][\'args\'][x][\'type\'][\'kind\'] == "LIST":\n                                            output_file.write("<span class=\'type\'>[{0}]</span><br>".format(\n                                                rt[i][\'fields\'][j][\'args\'][x][\'type\'][\'ofType\'][\'name\']))\n                                        # NOT NULL\n                                        elif rt[i][\'fields\'][j][\'args\'][x][\'type\'][\'kind\'] == "NON_NULL":\n                                            output_file.write("<span class=\'type\'>{0}!</span><br>".format(\n                                                rt[i][\'fields\'][j][\'args\'][x][\'type\'][\'ofType\'][\'name\']))\n                                        # Holds simple types like float, string, int etc.\n                                        else:\n                                            if rt[i][\'fields\'][j][\'args\'][x][\'type\'][\'name\'] is not None:\n                                                output_file.write("<span class=\'type\'>{0}</span><br>".format(\n                                                    rt[i][\'fields\'][j][\'args\'][x][\'type\'][\'name\']))\n                                    x += 1\n                            j += 1\n                    i += 1\n        # For None key exceptions use: except KeyError:\n        except Exception:\n            raise\n        # Close documentation\n        output_file.write("</body></html>")\n        output_file.close()\n    green_print("DONE")\n')
    __stickytape_write_module('inql/generators/schema.py', 'from __future__ import print_function\nimport json\n\nfrom inql.utils import open\n\n\ndef generate(argument, fpath="introspection.json", green_print=lambda s: print(s)):\n    """\n    Generate Schema JSON\n\n    :param argument: introspection query output\n    :param fpath: file output\n    :return: None\n    """\n    green_print("Writing Introspection Schema JSON")\n    with open(fpath, "w") as schema_file:\n        schema_file.write(json.dumps(argument, indent=4, sort_keys=True))\n    green_print("DONE")')
    __stickytape_write_module('inql/generators/cycles.py', 'from __future__ import print_function\nfrom inql.cycles import Graph, CyclesDetector\nfrom inql.utils import simplify_introspection\n\n\ndef generate(argument, fpath="cycles.txt", timeout=60, streaming=False, green_print=lambda s: print(s)):\n    """\n    Generate Cycles Founds file, or stream to stdout\n\n    :param argument: introspection query result\n    :param fpath: output result, if streaming is not enabled\n    :param timeout: exits cycle detector after that timeout\n    :param streaming: if True all the cycles will be outputed to stdout without being saved anywhere, useful when\n                      dealing with huge graphs\n    :return: None\n    """\n    simple_introspection = simplify_introspection(argument)\n    g = Graph(simple_introspection)\n    g.create()\n    cycles = CyclesDetector(g, timeout)\n    if streaming:\n        global i\n        i = 0\n        green_print("Streaming Query Cycles")\n\n        def print_cycle(cycle):\n            global i\n            i += 1\n            print("%s: %s" % (i, CyclesDetector.cycle_str(cycle)))\n\n        cycles.detect(on_cycle=print_cycle)\n    else:\n        green_print("Writing Query Cycles to %s" % fpath)\n        cycles.detect()\n        with open(fpath, \'w\') as f:\n            f.write(str(cycles))\n        green_print("DONE")')
    __stickytape_write_module('inql/cycles.py', 'from inql.utils import run_timeout\n\n\nclass Graph:\n    def __init__(self, data):\n        self.data = data\n        self._representation = {}\n        self.vertices = 0\n        self.edges = 0\n        self.graphQLTypes = ["Int", "String", "ID", "Boolean", "Float"]\n        self.excludeList = ["Mutation", "Query", "Subscription"]\n        self._created = False\n\n    def _add_to_graph(self, target):\n        for object_name in self.data[target]:\n            derived_by = []\n            if \'__implements\' in self.data[target][object_name]:\n                derived_by = self.data[target][object_name][\'__implements\'].keys()\n            is_derived = len(derived_by) > 0\n\n            if object_name not in self.excludeList:\n                self.vertices += 1\n                object_type = self.data[target][object_name]\n\n                tmp_reference_list = []\n\n                for fields in object_type.keys():\n                    if target == \'union\':\n                        type_name = fields\n                    else:\n                        if fields[0:2] == "__":\n                            continue\n                        if fields == \'type\':\n                            # FIXME: \'type\' key should not be here, this implies a name overload or malformed graphql\n                            #        definition. SKIP this node for the moment.\n                            continue\n                        type_name = object_type[fields][\'type\']\n\n                    if type_name not in self.graphQLTypes:\n                        if target == \'union\':\n                            tmp_reference_list.append({\n                                "label": "#union_ref",\n                                "reference": fields\n                            })\n                        else:\n                            tmp_reference_list.append({\n                                "label": fields,\n                                "reference": object_type[fields][\'type\']\n                            })\n\n                if is_derived:\n                    # this implies that the interface vertexes has been already added\n                    for der in derived_by:\n                        self._representation[der][\'referenceList\'].append({\n                            "label": "#interface_ref", "reference": object_name\n                        })\n\n                self._representation[object_name] = {\n                    "vertexID": object_name,\n                    "vertexType": target,\n                    "referenceList": tmp_reference_list\n                }\n\n    def _connect(self):\n        for vertex in list(self._representation.keys()):\n            for ref, ref_object in enumerate(self._representation[vertex][\'referenceList\']):\n                reference = ref_object[\'reference\']\n                self.edges += 1\n                if reference not in self._representation:\n                    if reference in self.excludeList:\n                        self._representation[reference] = {"vertexID": reference, "referenceList":[]}\n                    else:\n                        raise Exception("Field %s not defined" % reference)\n                ref_object[\'reference\'] = self._representation[reference]\n\n    def __repr__(self):\n        return str({\n            "vertices": self.vertices,\n            "edges": self.edges\n        })\n\n    def __str__(self):\n        s = "Graph("\n        for vertex in self._representation.keys():\n            s += "\\n\\t%s" % self._representation[vertex][\'vertexID\']\n            for reference, _ in enumerate(self._representation[vertex][\'referenceList\']):\n                s += "\\n\\t\\t-> %s" % self._representation[vertex][\'referenceList\'][reference][\'reference\'][\'vertexID\']\n        s += "\\n)"\n        return s\n\n    def create(self):\n        if self._created:\n            return self._representation\n\n        for basic_type in [\'enum\', \'scalar\']:\n            if basic_type in self.data:\n                self.graphQLTypes += self.data[basic_type].keys()\n\n        self._add_to_graph("interface")\n\n        self._add_to_graph("union")\n\n        self._add_to_graph("type")\n\n        self._connect()\n\n        self._created = True\n\n        return self._representation\n\nclass CyclesDetector:\n    def __init__(self, graph, timeout=None):\n        self.graph = graph\n        self.save_mode = 1\n        self.data = None\n        self.timeout = timeout\n\n    def detect(self, select=False, on_cycle=None):\n        if self.data:\n            return self.data\n\n        data = {}\n        data[\'foundCycle\'] = False\n        data[\'cycles\'] = []\n        data[\'numberCycles\'] = 0\n        tarjan = _TarjanAlgorithm(self.graph, select)\n        tarjan.execute()\n\n        data[\'SCCs\'] = len(tarjan.scc)\n        data[\'longestSCC\'] = 0\n\n        for component, _ in enumerate(tarjan.scc):\n            if len(tarjan.scc[component]) > data[\'longestSCC\']:\n                data[\'longestSCC\'] = len(tarjan.scc[component])\n\n        if select:\n            data[\'foundCycle\'] = tarjan.found_cycle\n            return data\n\n        tarjan.prune_edges()\n        if self.timeout is not None:\n            single_timeout = float(self.timeout) / len(tarjan.scc)\n        else:\n            single_timeout = None\n\n        for i, _ in enumerate(tarjan.scc):\n            try:\n                johnson = _JohnsonAlgorithm(tarjan.scc[i], on_cycle=on_cycle)\n                def timeout_execute():\n                    johnson.execute()\n                if self.timeout is not None:\n                    timeout_execute()\n                else:\n                    run_timeout(execute=timeout_execute, timeout=single_timeout)\n                johnson.stop = True\n                data[\'cycles\'] += johnson.cycles\n                data[\'numberCycles\'] += len(johnson.cycles)\n            except Exception as ex:\n                print(ex)\n                print("#Cycles found = %s" % len(johnson.cycles))\n                data[\'numberCycles\'] += len(johnson.cycles)\n                data[\'cycles\'] += johnson.cycles\n                return data\n\n        data[\'foundCycle\'] = (len(data[\'cycles\']) > 0)\n\n        self.data = data\n\n        return self\n\n    def __repr__(self):\n        return str(self.data)\n\n    def cycle_str(cycle):\n        s = "{ "\n        for c in cycle:\n            s += c[\'vertex\'][\'vertexID\']\n            if c[\'refLabel\'] == \'#interface_ref\':\n                s += "<~implements~ "\n            elif c[\'refLabel\'] == \'#union_ref\':\n                s += " -union-> "\n            elif c["refLabel"]:\n                s += " -[%s]-> " % c["refLabel"]\n            else:\n                s += " }"\n        return s\n    cycle_str = staticmethod(cycle_str)\n\n    def __str__(self):\n        s = "Cycles("\n        if self.data:\n            for cycle in self.data[\'cycles\']:\n                s += "\\n\\t%s" % CyclesDetector.cycle_str(cycle)\n        s += "\\n)"\n        return s\n\n\nclass _TarjanAlgorithm:\n    # XXX: It will have destructive effect on the graph object\n    def __init__(self, graph, select):\n        self.graph = graph._representation\n        self.stack = []\n        self.index = 0\n        self.found_cycle = False\n        self.scc = []\n        self.input = select\n\n    def execute(self):\n        for vertex in self.graph.keys():\n            if self.found_cycle:\n                return True\n            elif \'visited\' not in self.graph[vertex]:\n                self._strong_connect(self.graph[vertex])\n\n    def _strong_connect(self, vertex):\n\n        vertex[\'index\'] = self.index\n        vertex[\'lowlink\'] = self.index\n        self.index += 1\n        self.stack.append(vertex)\n        vertex[\'visited\'] = True\n        vertex[\'onStack\'] = True\n        for reference, _ in enumerate(vertex[\'referenceList\']):\n\n            if \'visited\' not in vertex[\'referenceList\'][reference][\'reference\']:\n                self._strong_connect(vertex[\'referenceList\'][reference][\'reference\'])\n                vertex[\'lowlink\'] = min(vertex[\'lowlink\'], vertex[\'referenceList\'][reference][\'reference\'][\'lowlink\'])\n            elif \'onStack\' in vertex[\'referenceList\'][reference][\'reference\'] and \\\n                    vertex[\'referenceList\'][reference][\'reference\'][\'onStack\']:\n                vertex[\'lowlink\'] = min(vertex[\'lowlink\'], vertex[\'referenceList\'][reference][\'reference\'][\'index\'])\n                if self.input:\n                    self.found_cycle = True\n                    return\n\n        if vertex[\'lowlink\'] == vertex[\'index\']:\n            tmp_scc = []\n            w = self.stack.pop()\n            w[\'lowlink\'] = vertex[\'index\']\n            w[\'onStack\'] = False\n            w[\'jIndex\'] = len(tmp_scc) # XXX: Used in johnson later\n            tmp_scc.append(w)\n            while w != vertex:\n                w = self.stack.pop()\n                w[\'lowlink\'] = vertex[\'index\']\n                w[\'onStack\'] = False\n                w[\'jIndex\'] = len(tmp_scc) # XXX: Used in johnson later\n                tmp_scc.append(w)\n            self.scc.append(tmp_scc)\n\n    def prune_edges(self):\n        scc = self.scc\n        for component, _ in enumerate(scc):\n            for vertex, _ in enumerate(scc[component]):\n                tmp_reference_list = scc[component][vertex][\'referenceList\'][:] # copy list to operate on that\n                i = 0\n                for ref, _ in enumerate(scc[component][vertex][\'referenceList\']):\n                    if scc[component][vertex][\'referenceList\'][ref][\'reference\'][\'lowlink\'] != scc[component][vertex][\'lowlink\']:\n                        del tmp_reference_list[ref+i]\n                        i -= 1\n                scc[component][vertex][\'referenceList\'] = tmp_reference_list\n\n\nclass _JohnsonAlgorithm:\n    def __init__(self, component, on_cycle=None):\n        self.component = component\n        self.cycles = []\n\n        self.blocked = [False for _ in self.component]\n        self.blocked_map = [[] for _ in self.component]\n        self.stack = []\n        self.stack_edges = []\n        self.found_cycle = False\n        self.start_vertex = 0\n        self.stop = False\n        self.on_cycle = on_cycle\n\n    def execute(self):\n        if self.stop: return\n        for vertex, _ in enumerate(self.component):\n            self.start_vertex = vertex\n            self._find_cycles(vertex)\n            self.blocked = [False for _ in self.component]\n            self.blocked_map = [[] for _ in self.component]\n\n    def _unblock(self, u):\n        if self.stop: return\n        self.blocked[u] = False\n        for w, _ in enumerate(self.blocked_map[u]):\n            if self.stop: return\n            target_block = self.blocked_map[u][w]\n            if self.blocked[target_block]:\n                self._unblock(target_block)\n        self.blocked_map[u] = []\n\n    def _find_cycles(self, v):\n        if self.stop: return self.found_cycle\n\n        result = []\n        self.stack.append(v) # push indexdx of vertex (in component)\n        self.blocked[v] = True\n        for edge, _ in enumerate(self.component[v][\'referenceList\']):\n            if self.stop: return self.found_cycle\n            edge_ref = self.component[v][\'referenceList\'][edge]\n            if edge_ref[\'reference\'][\'jIndex\'] == self.start_vertex:\n                self.found_cycle = True\n                self.stack_edges.append(edge_ref[\'label\'])\n\n                for item, _ in enumerate(self.stack):\n                    if self.stop: return self.found_cycle\n                    result.append({\n                        "vertex": self.component[self.stack[item]],\n                        "refLabel": self.stack_edges[item]\n                    })\n                result.append({\n                    "vertex": self.component[self.start_vertex],\n                    "refLabel": ""\n                })\n                if self.stack_edges: self.stack_edges.pop()\n                # it may be memory intensive for some graph, for this reason it\'s better to use the callback version\n                # in these cases\n                if self.on_cycle is not None:\n                    self.on_cycle(result)\n                else:\n                    # save result\n                    self.cycles.append(result)\n                result = []\n            elif not self.blocked[edge_ref[\'reference\'][\'jIndex\']] and self.start_vertex < edge_ref[\'reference\'][\'jIndex\'] \\\n                and edge_ref[\'reference\'][\'jIndex\'] not in self.stack:\n                self.stack_edges.append(edge_ref[\'label\'])\n                self.found_cycle = self._find_cycles(edge_ref[\'reference\'][\'jIndex\']) # bug ?\n\n        if self.found_cycle:\n            self._unblock(v)\n        else:\n            for wt, _ in enumerate(self.component[v][\'referenceList\']):\n                w = self.component[v][\'referenceList\'][wt][\'reference\'][\'jIndex\']\n                if v not in self.blocked_map[w]:\n                    self.blocked_map[w].append(v)\n\n        if self.stack: self.stack.pop()\n        if self.stack_edges: self.stack_edges.pop()\n        return self.found_cycle')
    __stickytape_write_module('inql/generators/query.py', 'from __future__ import print_function\n\nimport json\n\nfrom inql.utils import open, simplify_introspection\n\nORDER = {\n    "scalar": 0,\n    "enum": 1,\n    "type": 2,\n    "input": 3,\n    "interface": 4,\n    "union": 5\n}\nMINUS_INFINITE = -10000\n\n\ndef reverse_lookup_order(field, reverse_lookup):\n    try:\n        if field[\'required\']:\n            ret = 0\n        else:\n            ret = 10\n        if field[\'array\']:\n            ret += 100\n        if \'args\' in field:\n            ret += 1000\n        ret += ORDER[reverse_lookup[field[\'type\']]]\n        return ret\n    except KeyError:\n        return 10000\n\ndef recurse_fields(schema, reverse_lookup, t, max_nest=7, non_required_levels=1, dinput=None,\n                   params_replace=lambda schema, reverse_lookup, elem: elem, recursed=0):\n    """\n    Generates a JSON representation of the AST object representing a query\n\n    :param schema:\n        the output of a simplified schema\n\n    :param reverse_lookup:\n        a support hash that goes from typename to graphql type, useful to navigate the schema in O(1)\n\n    :param t:\n        type that you need to generate the AST for, since it is recursive it may be anything inside the graph\n\n    :param max_nest:\n        maximum number of recursive calls before returning the type name, this is needed in particularly broken cases\n        where recurse_fields may not exit autonomously (EG. hackerone.com is using union to create sql or/and/not\n        statements.) Consider that this will partially break params_replace calls.\n\n    :param non_required_levels:\n        expand up to non_required_levels levels automatically.\n\n    :param dinput:\n        the output object, it may even be provided from the outside.\n\n    :param params_replace:\n        a callback that takes (schema, reverse_lookup, elem) as parameter and returns a replacement for parameter.\n        Needed in case you want to generate real parameters for queries.\n\n    """\n    if max_nest == 0:\n        return params_replace(schema, reverse_lookup, t)\n    if t not in reverse_lookup:\n        return params_replace(schema, reverse_lookup, t)\n\n    if dinput is None:\n        dinput = {}\n\n    if reverse_lookup[t] in [\'type\', \'interface\', \'input\']:\n        for inner_t, v in sorted(schema[reverse_lookup[t]][t].items(), key=lambda kv: reverse_lookup_order(kv[1], reverse_lookup)):\n            if inner_t == \'__implements\':\n                for iface in v.keys():\n                    interface_recurse_fields = recurse_fields(schema, reverse_lookup, iface, max_nest=max_nest,\n                                                              non_required_levels=non_required_levels,\n                                                              params_replace=params_replace)\n                    dinput.update(interface_recurse_fields)\n                continue\n            # try to add at least one required inner, if you should not recurse anymore\n            recurse = non_required_levels > 0 or (v[\'required\'] and recursed <= 0) # required_only => v[\'required\']\n            if recurse:\n                dinput[inner_t] = recurse_fields(schema, reverse_lookup, v[\'type\'], max_nest=max_nest - 1,\n                                                 non_required_levels=non_required_levels - 1,\n                                                 params_replace=params_replace)\n                recursed += 1\n            if recurse and \'args\' in v:\n                if inner_t not in dinput or type(dinput[inner_t]) is not dict:\n                    dinput[inner_t] = {}\n                dinput[inner_t]["args"] = {}\n                for inner_a, inner_v in sorted(v[\'args\'].items(), key=lambda kv: reverse_lookup_order(kv[1], reverse_lookup)):\n                    # try to add at least a parameter, even if there are no required parameters\n                    recurse_inner = non_required_levels > 0 or inner_v[\'required\'] # required_only => v[\'required\']\n                    if recurse_inner:\n                        arg = recurse_fields(schema, reverse_lookup, inner_v[\'type\'], max_nest=max_nest-1, recursed=MINUS_INFINITE,\n                                             non_required_levels=non_required_levels-1, params_replace=params_replace)\n                        if \'array\' in inner_v and inner_v[\'array\']:\n                            if type(arg) is dict:\n                                arg = [arg]\n                            else:\n                                arg = "[%s]" % arg\n                        if \'required\' in inner_v and inner_v[\'required\']:\n                            if type(arg) is not dict:\n                                arg = "!%s" % arg\n                            else:\n                                pass  # XXX: don\'t handle required array markers, this is a bug, but simplifies a lot the code\n                        dinput[inner_t][\'args\'][inner_a] = arg\n                if len(dinput[inner_t]["args"]) == 0:\n                    del dinput[inner_t]["args"]\n                if len(dinput[inner_t]) == 0:\n                    del dinput[inner_t]\n\n        if len(dinput) == 0 and (t not in reverse_lookup or reverse_lookup[t] not in [\'enum\', \'scalar\']):\n            items = list(schema[reverse_lookup[t]][t].items())\n            if len(items) > 0:\n                inner_t, v = items[0]\n                dinput[inner_t] = recurse_fields(schema, reverse_lookup, v[\'type\'], max_nest=max_nest - 1,\n                                                non_required_levels=non_required_levels - 1, params_replace=params_replace)\n    elif reverse_lookup[t] == \'union\':\n        # select the first type of the union\n        for union in schema[\'union\'][t].keys():\n            dinput["... on %s" % union] = recurse_fields(schema, reverse_lookup, union, max_nest=max_nest,\n                                                         non_required_levels=non_required_levels,\n                                                         params_replace=params_replace)\n    elif reverse_lookup[t] in [\'enum\', \'scalar\']:\n        # return the type since it is an enum\n        return params_replace(schema, reverse_lookup, t)\n    return dinput\n\n\ndef dict_to_args(d):\n    """\n    Generates a string representing query arguments from an AST dict.\n\n    :param d: AST dict\n    """\n    args = []\n    for k, v in d.items():\n        args.append("%s:%s" % (k, json.dumps(v).replace(\'"\', \'\').replace("u\'", "").replace("\'", "").replace(\'@\', \'"\')))\n    if len(args) > 0:\n        return "(%s)" % \', \'.join(args)\n    else:\n        return ""\n\n\ndef dict_to_qbody(d, prefix=\'\'):\n    """\n    Generates a string representing a query body from an AST dict.\n\n    :param d: AST dict\n    :param prefix: needed in case it will recurse\n    """\n    if type(d) is not dict:\n        return \'\'\n    s = \'\'\n    iprefix = prefix + \'\\t\'\n    args = \'\'\n    for k, v in d.items():\n        if k == \'args\':\n            args = dict_to_args(v)\n        elif type(v) is dict:\n            s += \'\\n\' + iprefix + k + dict_to_qbody(v, prefix=iprefix)\n        else:\n            s += \'\\n\' + iprefix + k\n    if len(s) > 0:\n        return "%s {%s\\n%s}" % (args, s, prefix)\n    else:\n        return args\n\n\ndef preplace(schema, reverse_lookup, t):\n    """\n    Replaces basic types and enums with default values.\n\n    :param schema:\n        the output of a simplified schema\n\n    :param reverse_lookup:\n        a support hash that goes from typename to graphql type, useful to navigate the schema in O(1)\n\n    :param t:\n        type that you need to generate the AST for, since it is recursive it may be anything inside the graph\n\n    """\n    if t == \'String\':\n        return \'@code*@\'\n    elif t == \'Int\':\n        return 1334\n    elif t == \'Boolean\':\n        return \'true\'\n    elif t == \'Float\':\n        return 0.1334\n    elif t == \'ID\':\n        return 14\n    elif reverse_lookup[t] == \'enum\':\n        return list(schema[\'enum\'][t].keys())[0]\n    elif reverse_lookup[t] == \'scalar\':\n        # scalar may be any type, so the AST can be anything as well\n        # since the logic is custom implemented I have no generic way of replacing them\n        # for this reason we return it back as they are\n        return t\n    else:\n        return t\n\n\ndef generate(argument, qpath="%s/%s", detect=True, green_print=lambda s: print(s)):\n    """\n    Generate query templates\n\n    :param argument: introspection query result\n    :param qpath:\n        directory template where to output the queries, first parameter is type of query and second is query name\n\n    :param detect:\n        retrieve placeholders according to arg type\n\n    :param green_print:\n        implements print in green\n\n    :return: None\n    """\n    s = simplify_introspection(argument)\n\n    rev = {\n        "String": \'scalar\',\n        "Int": \'scalar\',\n        "Float": \'scalar\',\n        "Boolean": \'scalar\',\n        "ID": \'scalar\',\n    }\n    for t, v in s.items():\n        for k in v.keys():\n            rev[k] = t\n\n    for qtype, qvalues in s[\'schema\'].items():\n        green_print("Writing %s Templates" % qtype)\n        if detect:\n            rec = recurse_fields(s, rev, qvalues[\'type\'], non_required_levels=2, params_replace=preplace)\n        else:\n            rec = recurse_fields(s, rev, qvalues[\'type\'], non_required_levels=2)\n        for qname, qval in rec.items():\n            print("Writing %s %s" % (qname, qtype))\n            with open(qpath % (qtype, \'%s.query\' % qname), \'w\') as ofile:\n                body = "%s {\\n\\t%s%s\\n}" % (qtype, qname, dict_to_qbody(qval, prefix=\'\\t\'))\n                if detect:\n                    body = body.replace(\'!\', \'\')\n                query = {"query": body}\n                ofile.write(json.dumps(query))\n\n    green_print("DONE")')
    __stickytape_write_module('inql/generators/tsv.py', 'from __future__ import print_function\nfrom inql.generators.query import recurse_fields\nfrom inql.utils import simplify_introspection, open\n\ndef extract_args(val, returns):\n    """\n    Recursive method that extract all the arguments name available in the present queries\n\n    :param val: the IIR sub value, already recursively rebuilt\n    :param returns: the support set containing the return value, it should be empty on the first iteration\n    """\n    if type(val) is not dict:\n        return returns\n\n    for k, v in val.items():\n        if k == \'args\':\n            # extract returns also work as a name inference for arguments due to the json struct\n            extract_returns(v, returns)\n        if type(v) is dict:\n            extract_args(v, returns)\n\n    return returns\n\n\ndef extract_args_types(val, returns):\n    """\n    Recursive method that extract all the arguments types available in the present queries\n\n    :param val: the IIR sub value, already recursively rebuilt\n    :param returns: the support set containing the return value, it should be empty on the first iteration\n    """\n    if type(val) is not dict:\n        returns.add(val)\n        return returns\n\n    for k, v in val.items():\n        if k == \'args\':\n            # extract returns types also work as a name inference for arguments due to the json struct\n            extract_returns_types(v, returns)\n        if type(v) is dict:\n            extract_args_types(v, returns)\n\n    return returns\n\ndef extract_returns(val, returns):\n    """\n    Recursive method that extract all the returns name available in the present queries\n\n    :param val: the IIR sub value, already recursively rebuilt\n    :param returns: the support set containing the return value, it should be empty on the first iteration\n    """\n    if type(val) is not dict:\n        return returns\n\n    for k, v in val.items():\n        if k == \'args\':\n            continue\n        if type(v) is dict:\n            extract_returns(v, returns)\n        elif type:\n            returns.add(k)\n\n    return returns\n\n\ndef extract_returns_types(val, returns):\n    """\n    Recursive method that extract all the returns types available in the present queries\n\n    :param val: the IIR sub value, already recursively rebuilt\n    :param returns: the support set containing the return value, it should be empty on the first iteration\n    """\n    if type(val) is not dict:\n        returns.add(val)\n        return returns\n\n    for k, v in val.items():\n        if k == \'args\':\n            continue\n        if type(v) is dict:\n            extract_returns_types(v, returns)\n        elif type(v) is list:\n            for v_inner in v:\n                extract_returns(v_inner, returns)\n        else:\n            returns.add(v)\n\n    return returns\n\n\ndef joinset(input_set):\n    return \', \'.join(sorted(list(input_set)))\n\n\ndef generate(argument, fpath="endpoints_%.tsv", green_print=lambda s: print(s)):\n    """\n    Generate Cycles Founds file, or stream to stdout\n\n    :param argument: introspection query result\n    :param fpath: output result format string, the first %s will be used as query type (mutation, susbscription, ...)\n    :return: None\n    """\n    s = simplify_introspection(argument)\n\n    rev = {}\n    for t, v in s.items():\n        for k in v.keys():\n            rev[k] = t\n\n    for qtype, qvalues in s[\'schema\'].items():\n        rec = recurse_fields(s, rev, qvalues[\'type\'], non_required_levels=2)\n        path = fpath % qtype\n        green_print("Writing %s TSV" % qtype)\n        with open(path, "w") as tsv_file:\n            tsv_file.write("Operation Name\\tArgs Name\\tArgs Types\\tReturns Name\\tReturns Types\\n")\n            for qname, qval in rec.items():\n                print("Writing %s %s in TSV" % (qname, qtype))\n                tsv_file.write("%s\\t%s\\t%s\\t%s\\t%s\\n" % (qname,\n                                       joinset(extract_args(qval, set())),\n                                       joinset(extract_args_types(qval, set())),\n                                       joinset(extract_returns(qval, set())),\n                                       joinset(extract_returns_types(qval, set()))))\n        green_print("DONE")')
    __stickytape_write_module('inql/widgets/omnibar.py', 'import platform\n\nfrom inql.utils import nop_evt\n\nif platform.system() != "Java":\n    print("Load this file inside jython, if you need the stand-alone tool run: inql")\n    exit(-1)\n\nfrom java.awt.event import FocusListener, KeyAdapter, KeyEvent\nfrom javax.swing import JFrame, JPanel, JTextField, JButton\nfrom java.awt import (BorderLayout, Color)\n\n\nclass _HintTextField(FocusListener, KeyAdapter):\n    """\n    HintTextField is a class responsible for showing an hint while the textfield is empty\n    """\n\n    def __init__(self, hint=None, action=None):\n        if not hint: hint = \'hint\'\n        if not action: action = nop_evt\n        self.this = JTextField(hint)\n        self._hint = hint\n        self._showing_hint = True\n        self._enter_listener = None\n        self.this.addFocusListener(self)\n        self.this.addKeyListener(self)\n        self.set_enter_evt_listener(action)\n\n    def set_enter_evt_listener(self, enter_listener):\n        """\n        Add an evt listener to HintTextField\n\n        :param enter_listener: lambda event listener\n        :return:\n        """\n        self._enter_listener = enter_listener\n\n    def keyPressed(self, e):\n        """\n        KeyAdapter override\n\n        :param e: event containing the key pressed\n        :return: None\n        """\n        if self._enter_listener and e.getKeyCode() == KeyEvent.VK_ENTER:\n            self._enter_listener(e)\n      \n    def focusGained(self, e):\n        """\n        FocusListener override\n\n        :param e: unused\n        :return: None\n        """\n        if self.getText() == "":\n            self.this.setText("")\n            self._showing_hint = False\n\n    def focusLost(self, e):\n        """\n        FocusListener override\n\n        :param e: unused\n        :return: None\n        """\n        if self.getText() == "":\n            self.this.setText(self._hint)\n            self._showing_hint = True\n\n    def getText(self):\n        """\n        :return: the current text or "" if no text is wrote inside the textfield\n        """\n        if self._showing_hint:\n            return ""\n        else:\n            return self.this.getText()\n\n    def setText(self, txt):\n        """\n        Set Text\n\n        :param txt: a string\n        :return: None\n        """\n        self.this.setText(txt)\n        self._showing_hint = False\n\n    def reset(self):\n        """\n        Reset the HintBox\n        :return: None\n        """\n        self.this.setText(self._hint)\n        self._showing_hint = True\n\nclass Omnibar:\n    """\n    Omnibar represents a chrome alike textbox with behaviour similar to the one of a normal browser\n    """\n\n    def __init__(self, hint=None, label=None, action=None):\n        if not hint: hint = \'Omnibar hint\'\n        if not label: label = \'Run\'\n        if not action: action = nop_evt\n        self.this = JPanel()\n        self.this.setLayout(BorderLayout())\n\n        # Add an hinttextfield\n        self._text = _HintTextField(hint, action)\n        self.this.add(BorderLayout.CENTER, self._text.this)\n\n        # Add a run buttpn\n        button = JButton(label)\n        button.addActionListener(action)\n        self.this.add(BorderLayout.EAST, button)\n\n    def getText(self):\n        """\n        :return: the current text or "" if no text is wrote inside the textfield\n        """\n        return self._text.getText()\n\n    def setText(self, txt):\n        """\n        Set Text\n\n        :param txt: a string\n        :return: None\n        """\n        self._text.setText(txt)\n\n    def reset(self):\n        """\n        Reset the HintBox\n        :return: None\n        """\n        self._text.reset()\n\nif __name__ == "__main__":\n    frame = JFrame("Omnibar")\n    frame.setForeground(Color.black)\n    frame.setBackground(Color.lightGray)\n    cp = frame.getContentPane()\n    cp.add(Omnibar().this)\n    frame.pack()\n    frame.setVisible(True)\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)')
    __stickytape_write_module('inql/widgets/fileview.py', 'import platform\n\nif platform.system() != "Java":\n    print("Load this file inside jython, if you need the stand-alone tool run: inql")\n    exit(-1)\n\nimport os\nimport json\n\nfrom javax.swing import JSplitPane, JFrame\nfrom java.awt import BorderLayout, Color\n\nfrom filetree import FileTree\nfrom payloadview import PayloadView\n\nclass FileView:\n    """\n    SplitPane containing an editoresque (Sublime-alike) filetree+editor widget\n    """\n    def __init__(self, dir=None, filetree_label=None, texteditor_factory=None):\n        if not dir: dir = os.getcwd()\n        self._filetree = FileTree(dir=dir, label=filetree_label)\n        self._payloadview = PayloadView(texteditor_factory=texteditor_factory)\n        self.this = JSplitPane(JSplitPane.HORIZONTAL_SPLIT,\n                               self._filetree.this, self._payloadview.this)\n        self.this.setOneTouchExpandable(True)\n        self._filetree.add_tree_selection_listener(self._tree_listener)\n        self.this.getRightComponent().setVisible(False)\n\n    def _tree_listener(self, e):\n        """\n        Listen for tree selection and fill the payloadview\n\n        :param e: unused\n        :return: None\n        """\n        try:\n            fpath = os.path.join(*[str(p) for p in e.getPath().getPath()][1:])\n\n            if fpath.endswith(\'.html\'):\n                self.this.getRightComponent().setVisible(False)\n                return\n\n            with open(fpath, \'r\') as f:\n                payload = f.read()\n                self._payloadview.set_editable(True)\n                self._payloadview.refresh(payload)\n                self.this.getRightComponent().setVisible(True)\n                self.this.setDividerLocation(0.25)\n        except IOError:\n            pass\n\n    def addTreeListener(self, action):\n        """\n        Add a new Tree ActionListener\n\n        :param action: actionListener lambda\n        :return:\n        """\n        self._filetree.add_tree_selection_listener(action)\n\n    def addPayloadListener(self, action):\n        """\n        Add a new PayloadView Listener\n\n        :param action: actionListener lambda\n        :return:\n        """\n        self._payloadview.add_listener(action)\n\n    def refresh(self):\n        self._filetree.refresh()\n\nif __name__ == "__main__":\n    frame = JFrame("FileView")\n    frame.setForeground(Color.black)\n    frame.setBackground(Color.lightGray)\n    cp = frame.getContentPane()\n    cp.add(FileView().this)\n    frame.pack()\n    frame.setVisible(True)\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)')
    __stickytape_write_module('inql/widgets/filetree.py', 'import platform\n\nif platform.system() != "Java":\n    print("Load this file inside jython, if you need the stand-alone tool run: inql")\n    exit(-1)\n\nimport os\n\nfrom java.awt import (BorderLayout, Color, Container, Dimension, Component)\nfrom java.io import File\nfrom java.util import Vector, Collections\nfrom javax.swing import (BoxLayout, JFrame, JPanel, JScrollPane, JTree, JLabel)\nfrom javax.swing.tree import (DefaultMutableTreeNode, DefaultTreeModel)\n\n\nclass FileTree:\n    """\n    TreeView widget containing a filetree\n    """\n\n    def __init__(self, dir=None, label=None):\n        if not dir: dir = os.getcwd()\n        if not label: label = "FileTree"\n        dir = File(dir)\n        self._dir = dir\n        self.this = JPanel()\n        self.this.setLayout(BorderLayout())\n\n        # Add a label\n        self.this.add(BorderLayout.PAGE_START, JLabel(label))\n\n        # Make a tree list with all the nodes, and make it a JTree\n        tree = JTree(self._add_nodes(None, dir))\n        tree.setRootVisible(False)\n        self._tree = tree\n\n        # Lastly, put the JTree into a JScrollPane.\n        scrollpane = JScrollPane()\n        scrollpane.getViewport().add(tree)\n        self.this.add(BorderLayout.CENTER, scrollpane)\n\n    def refresh(self):\n        """\n        Refresh TreeModel when the directory is updated\n\n        :return: None\n        """\n        self._tree.setModel(DefaultTreeModel(self._add_nodes(None, self._dir)))\n\n    def _add_nodes(self, curTop, dir):\n        """\n        Recursive implementation to fill the tree with filenames and directories\n\n        :param curTop: current top directory\n        :param dir: next directory\n        :return: None\n        """\n        curPath = dir.getPath()\n        if os.path.isdir(curPath):\n            nodePath = os.path.basename(curPath)\n        curDir = DefaultMutableTreeNode(nodePath)\n        if curTop != None:  # should only be null at root\n            curTop.add(curDir)\n        ol = Vector()\n        tmp = dir.list()\n        for i in xrange(0, len(tmp)):\n            ol.addElement(tmp[i])\n        thisObject = None\n        files = Vector()\n        # Make two passes, one for Dirs and one for Files. This is #1.\n        for i in xrange(0, ol.size()):\n            thisObject = ol.elementAt(i)\n            if curPath == self._dir:\n                newPath = thisObject\n            else:\n                newPath = os.path.join(curPath, thisObject)\n            f = File(newPath)\n            if f.isDirectory():\n                self._add_nodes(curDir, f)\n            else:\n                files.addElement(thisObject)\n\n        # Pass two: for files.\n        Collections.sort(files)\n        for i in xrange(0, files.size()):\n            f = files.elementAt(i)\n            #if f.split(\'.\')[-1] != \'html\':\n            curDir.add(DefaultMutableTreeNode(files.elementAt(i)))\n        return curDir\n\n    def add_tree_selection_listener(self, listener):\n        """\n        Wrapper for the inner tree selection listener callback register function\n\n        :param listener: a new listener\n        :return: None\n        """\n        self._tree.addTreeSelectionListener(listener)\n\n\nif __name__ == "__main__":\n    frame = JFrame("FileTree")\n    frame.setForeground(Color.black)\n    frame.setBackground(Color.lightGray)\n    cp = frame.getContentPane()\n    cp.add(FileTree().this)\n    frame.pack()\n    frame.setVisible(True)\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)\n')
    __stickytape_write_module('inql/burp_ext/timer_tab.py', 'from __future__ import print_function\n\nimport platform\n\nfrom inql.utils import is_query\n\nif platform.system() != "Java":\n    print("Load this file inside jython, if you need the stand-alone tool run: inql")\n    exit(-1)\n\nfrom burp import ITab, IHttpListener, IMessageEditorController, IBurpExtenderCallbacks\nfrom java.lang import System\nfrom javax.swing import JTable\nfrom java.time import LocalDateTime\nfrom java.util import HashMap\n\nfrom org.python.modules import synchronize\n\nfrom inql.widgets.timer import TimerPanel, Log\n\nimport json\n\nclass TimerTab(ITab, IHttpListener):\n    def __init__(self, callbacks, helpers):\n        self._callbacks = callbacks\n        self._helpers = helpers\n        self.isRunning = True\n        self.toolFilter = 0\n        self.reqResMap = HashMap()\n        callbacks.registerHttpListener(self);\n        self.panel = TimerPanel(\n            logtable_factory=lambda model: LogTable(model, self._callbacks),\n            external_clear_button_action_listener=lambda e: self.getReqResMap().clear(),\n            external_start_button_action_listener=lambda e: self.setRunning(True),\n            external_stop_button_action_listener=lambda e: self.setRunning(False),\n            external_filter_action_listener=self.filter_action_listener,\n            tools_keys=["All", "Proxy", "Intruder", "Scanner", "Repeater"]\n        )\n\n    def getTabCaption(self):\n        """\n        Override ITab method\n        :return: tab name\n        """\n        return "InQL Timer"\n\n    def getUiComponent(self):\n        """\n        Override ITab method\n        :return: Tab UI Component\n        """\n        self._callbacks.customizeUiComponent(self.panel.this)\n        return self.panel.this\n\n    def filter_action_listener(self, e):\n        tool = e.getSource().getSelectedItem()\n        if tool == "All":\n            self.setToolFilter(0)\n        elif tool == "Proxy":\n            self.setToolFilter(IBurpExtenderCallbacks.TOOL_PROXY)\n        elif tool == "Intruder":\n            self.setToolFilter(IBurpExtenderCallbacks.TOOL_INTRUDER)\n        elif tool == "Scanner":\n            self.setToolFilter(IBurpExtenderCallbacks.TOOL_SCANNER)\n        elif tool == "Repeater":\n            self.setToolFilter(IBurpExtenderCallbacks.TOOL_REPEATER)\n        else:\n            raise RuntimeError("Unknown tool: %s" % tool)\n\n    def setRunning(self, running):\n        self.isRunning = running\n\n    def setToolFilter(self, toolFilter):\n        self.toolFilter = toolFilter\n\n    def processHttpMessage(self, toolFlag, messageIsRequest, requestResponse):\n\n        if self.isRunning:\n            if self.toolFilter == 0 or self.toolFilter == toolFlag:\n                messageInfo = self._helpers.analyzeRequest(requestResponse)\n                url = messageInfo.getUrl()\n                requestBody = requestResponse.getRequest()[messageInfo.getBodyOffset():].tostring()\n                if not is_query(requestBody):\n                    return # exit early\n                qobj = json.loads(requestBody)\n                queryBody = ""\n                operationName = ""\n                if \'query\' in qobj:\n                    queryBody = qobj[\'query\']\n                if \'operationName\' in qobj:\n                    operationName = qobj[\'operationName\']\n                if messageIsRequest:\n                    self.reqResMap.put(url, System.currentTimeMillis())\n                elif self.reqResMap.containsKey(url):\n                    time = System.currentTimeMillis() - self.reqResMap.get(url)\n                    self.reqResMap.remove(url)\n                    # create a new log entry with the message details\n                    synchronize.apply_synchronized(self.panel.getLogTableModel().getLogArray(),\n                                                   self.syncProcessHttpMessage,\n                                                   (toolFlag, requestResponse, time, queryBody, operationName))\n\n    def syncProcessHttpMessage(self, toolFlag, messageInfo, time, queryBody, operationName):\n        row = self.panel.getLogTableModel().getLogArray().size()\n        # Log all requests - the default\n        if not self.panel.getQueryFilterText() and not self.panel.isScopeSelected():\n            self.addLog(messageInfo, toolFlag, time, row, operationName)\n        # Log filter URL requests\n        elif not self.panel.isScopeSelected() and self.panel.getQueryFilterText() and \\\n            self.panel.getQueryFilterText() in queryBody:\n            self.addLog(messageInfo, toolFlag, time, row, operationName)\n        # Log in-scope requests\n        elif self.panel.isScopeSelected() and not self.panel.getQueryFilterText() and \\\n              self._callbacks.isInScope(self._helpers.analyzeRequest(messageInfo).getUrl()):\n            self.addLog(messageInfo, toolFlag, time, row, operationName)\n        # Log in-scope requests and filter\n        elif self.panel.isScopeSelected() and self.panel.getQueryFilterText() and \\\n                self._callbacks.isInScope(self._helpers.analyzeRequest(messageInfo).getUrl()) and \\\n                self.panel.getQueryFilterText() in queryBody:\n            self.addLog(messageInfo, toolFlag, time, row, operationName)\n\n    def addLog(self, messageInfo, toolFlag, time, row, operationName):\n\n        self.panel.getLogTableModel().getLogArray().add(Log(LocalDateTime.now(),\n                                                           self._callbacks.getToolName(toolFlag),\n                                                           self._callbacks.saveBuffersToTempFiles(messageInfo),\n                                                           self._helpers.analyzeRequest(messageInfo).getUrl(),\n                                                           self._helpers.analyzeResponse(messageInfo.getResponse()).getStatusCode(),\n                                                           operationName,\n                                                           time))\n        self.panel.getLogTableModel().fireTableRowsInserted(row, row)\n\n    def getReqResMap(self):\n        return self.reqResMap\n\nclass LogTable(JTable, IMessageEditorController):\n    def __init__(self, logTableModel, callbacks):\n        JTable.__init__(self, logTableModel)\n        self.logTableModel = logTableModel\n        self.requestViewer = callbacks.createMessageEditor(self, False)\n        self.responseViewer = callbacks.createMessageEditor(self, False)\n        self.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS)\n        self.getColumnModel().getColumn(0).setMinWidth(200)\n        self.getColumnModel().getColumn(1).setMinWidth(100)\n        self.getColumnModel().getColumn(2).setPreferredWidth(1000)\n        self.getColumnModel().getColumn(3).setMinWidth(100)\n        self.getColumnModel().getColumn(4).setMinWidth(150)\n        self.getColumnModel().getColumn(5).setMinWidth(100)\n        self.setAutoCreateRowSorter(True)\n        self.currentlyDisplayedItem = None\n\n    def getRequest(self):\n        return self.currentlyDisplayedItem.getRequest()\n\n    def getResponse(self):\n        return self.currentlyDisplayedItem.getResponse()\n\n    def getHttpService(self):\n        return self.currentlyDisplayedItem.getHttpService()\n\n    def changeSelection(self, row, col, toggle, extend):\n        # show the log entry for the selected row\n        logEntry = self.logTableModel.getLogArray().get(self.convertRowIndexToModel(row))\n        self.requestViewer.setMessage(logEntry.requestResponse.getRequest(), True)\n        self.responseViewer.setMessage(logEntry.requestResponse.getResponse(), False)\n        self.currentlyDisplayedItem = logEntry.requestResponse\n\n        self.super__changeSelection(row, col, toggle, extend)\n\n    def getRequestViewer(self):\n        return self.requestViewer\n\n    def getResponseViewer(self):\n\n        return self.responseViewer\n')
    __stickytape_write_module('inql/widgets/timer.py', 'import platform\n\nif platform.system() != "Java":\n    print("Load this file inside jython, if you need the stand-alone tool run: inql")\n    exit(-1)\n\nfrom java.lang import Object as JavaObject, String as JavaString, Short as JavaShort, Long as JavaLong\nfrom java.util import ArrayList as JavaArrayList\nfrom javax.swing.table import AbstractTableModel\nfrom javax.swing import JPanel, BoxLayout, JSplitPane, JScrollPane, JTabbedPane, BorderFactory, JLabel, JButton, JComboBox, JCheckBox, JTextField\nfrom java.awt import Color, FlowLayout\n\nclass TimerPanel:\n    def __init__(self,\n                 logtable_factory=None,\n                 external_filter_action_listener=None,\n                 external_start_button_action_listener=None,\n                 external_stop_button_action_listener=None,\n                 external_clear_button_action_listener=None,\n                 tools_keys=None):\n        self.this = JPanel()\n\n        if tools_keys is None:\n            tools_keys = []\n\n        self.external_start_button_action_listener = external_start_button_action_listener\n        self.external_stop_button_action_listener = external_stop_button_action_listener\n        self.external_clear_button_action_listener = external_clear_button_action_listener\n\n\n        self.this.setLayout(BoxLayout(self.this, BoxLayout.Y_AXIS))\n\n        # main split pane\n        splitPane = JSplitPane(JSplitPane.VERTICAL_SPLIT)\n\n        # table of log entries\n        logTableModel = LogTableModel()\n        self.logTableModel = logTableModel\n        if logtable_factory is not None:\n            logTable = logtable_factory(logTableModel)\n        else:\n            # XXX: create a generic logtable that works even without burp to made it work standalone\n            raise ValueError("logtable_factory cannot be none")\n        scrollPane = JScrollPane(logTable)\n        splitPane.setLeftComponent(scrollPane)\n\n        # tabs with request/response viewers\n        tabs = JTabbedPane()\n        tabs.setBorder(BorderFactory.createLineBorder(Color.black))\n        tabs.addTab("Request", logTable.getRequestViewer().getComponent())\n        tabs.addTab("Response", logTable.getResponseViewer().getComponent())\n        splitPane.setRightComponent(tabs)\n\n        # top control panel\n        controlPanel = JPanel(FlowLayout(FlowLayout.LEFT))\n\n        toolLabel = JLabel("Select tool: ")\n        controlPanel.add(toolLabel)\n\n\n        tools = JavaArrayList(tools_keys)\n        toolList = JComboBox(tools)\n        toolList.addActionListener(external_filter_action_listener)\n        controlPanel.add(toolList)\n\n        startButton = JButton("Start")\n        self.startButton = startButton\n        controlPanel.add(startButton)\n        stopButton = JButton("Stop")\n        self.stopButton = stopButton\n        controlPanel.add(stopButton)\n        clearButton = JButton("Clear")\n        self.clearButton = clearButton\n        startButton.setEnabled(False)\n        controlPanel.add(clearButton)\n        scopeLabel = JLabel("In-scope items only?")\n        controlPanel.add(scopeLabel)\n        scopeCheckBox = JCheckBox()\n        self.scopeCheckBox = scopeCheckBox\n        controlPanel.add(scopeCheckBox)\n        filterLabel = JLabel("Filter Query:")\n        controlPanel.add(filterLabel)\n        queryFilterText = JTextField(40)\n        self.queryFilterText = queryFilterText\n        controlPanel.add(queryFilterText)\n\n        startButton.addActionListener(self.start_button_action_listener)\n\n        stopButton.addActionListener(self.stop_button_action_listener)\n\n        clearButton.addActionListener(self.clear_button_action_listener)\n\n        controlPanel.setAlignmentX(0)\n        self.this.add(controlPanel)\n        self.this.add(splitPane)\n\n    def getTabCaption(self):\n        return "Request Timer"\n    \n    def getUiComponent(self):\n        return self.this\n\n    def getLogTableModel(self):\n        return self.logTableModel\n    \n\n    def getQueryFilterText(self):\n        return self.queryFilterText.getText()\n    \n\n    def isScopeSelected(self):\n        return self.scopeCheckBox.isSelected()\n\n    def start_button_action_listener(self, e):\n        self.external_start_button_action_listener(e)\n        self.startButton.setEnabled(False)\n        self.stopButton.setEnabled(True)\n\n    def stop_button_action_listener(self, e):\n        self.external_stop_button_action_listener(e)\n        self.startButton.setEnabled(True)\n        self.stopButton.setEnabled(False)\n\n    def clear_button_action_listener(self, e):\n        self.external_clear_button_action_listener(e)\n        self.logTableModel.getLogArray().clear()\n        self.logTableModel.fireTableDataChanged()\n\n\nclass Log:\n    def __init__(self, timestamp, tool, requestResponse, url, status, operationName, time):\n        self.timestamp = timestamp\n        self.tool = tool\n        self.requestResponse = requestResponse\n        self.url = url\n        self.time = time\n        self.status = status\n        self.operationName = operationName\n\n\nclass LogTableModel(AbstractTableModel):\n    def __init__(self):\n        self.logArray = JavaArrayList()\n        self.names = ["Timestamp", "Tool", "Request URL", "Operation Name", "Response Time (ms)", "HTTP Status"]\n        self.classes = [JavaString, JavaString, JavaString, JavaString, JavaLong, JavaShort]\n\n    def getRowCount(self):\n        return len(self.logArray)\n\n    def getColumnCount(self):\n        return len(self.names)\n\n    def getColumnName(self, columnIndex):\n        if columnIndex < 0 or columnIndex > len(self.names):\n            return ""\n        return self.names[columnIndex]\n\n    def getColumnClass(self, columnIndex):\n        if columnIndex < 0 or columnIndex > len(self.classes):\n            return JavaObject.getClass()\n        return self.classes[columnIndex]\n\n    def getValueAt(self, rowIndex, columnIndex):\n        entry = self.logArray[rowIndex]\n        if columnIndex == 0:\n            return entry.timestamp\n        elif columnIndex == 1:\n            return entry.tool\n        elif columnIndex == 2:\n            return entry.url.toString()\n        elif columnIndex == 3:\n            return entry.operationName\n        elif columnIndex == 4:\n            return entry.time\n        elif columnIndex == 5:\n            return entry.status\n        else:\n            return ""\n\n    def getLogArray(self):\n        return self.logArray')
    __stickytape_write_module('burp_ext/__init__.py', '')
    """
    STUB file to make stickytape happy with import from __future__ statements.
    """
    
    import platform
    
    if platform.system() == "Java":
    	from burp_ext.extender import BurpExtender